From 216725151c9a50fa6d2c2eb756e143a4b9fadfd2 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sat, 3 Dec 2022 16:46:19 +0800
Subject: [PATCH 01/11] strokegen engine basic framework try#1
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

implemented based on BasicEngine, EEVEE Next, and the code snippet given by Cl√©ment Foucault.

Including
1) the integration into blender ui,
2) instance(empty yet)
3) shader module
---
 source/blender/draw/CMakeLists.txt            |   8 +
 .../shaders/infos/strokegen_depth_info.hh     |  65 +++
 .../shaders/strokegen_depth_curves_vert.glsl  |  27 ++
 .../shaders/strokegen_depth_frag.glsl         |   5 +
 .../strokegen_depth_pointcloud_vert.glsl      |  15 +
 .../shaders/strokegen_depth_vert.glsl         |  14 +
 .../strokgen_conservative_depth_geom.glsl     |  51 +++
 .../engines/strokegen/strokegen_engine.cc     | 413 ++++++++++++++++++
 .../draw/engines/strokegen/strokegen_engine.h |  31 ++
 .../engines/strokegen/strokegen_instance.cc   |  29 ++
 .../engines/strokegen/strokegen_instance.hh   |  75 ++++
 .../engines/strokegen/strokegen_shader.cc     | 119 +++++
 .../engines/strokegen/strokegen_shader.hh     |  62 +++
 source/blender/draw/intern/draw_manager.c     |   4 +
 14 files changed, 918 insertions(+)
 create mode 100644 source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh
 create mode 100644 source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl
 create mode 100644 source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl
 create mode 100644 source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl
 create mode 100644 source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl
 create mode 100644 source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_engine.cc
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_engine.h
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_instance.cc
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_instance.hh
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_shader.cc
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_shader.hh

diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
index 2093c8a2331..76bdd97ae20 100644
--- a/source/blender/draw/CMakeLists.txt
+++ b/source/blender/draw/CMakeLists.txt
@@ -208,6 +208,11 @@ set(SRC
   engines/overlay/overlay_viewer_attribute.cc
   engines/overlay/overlay_volume.cc
   engines/overlay/overlay_wireframe.cc
+  engines/strokegen/strokegen_engine.cc
+  engines/strokegen/strokegen_shader.cc
+  engines/strokegen/strokegen_instance.cc
+
+
 
   DRW_engine.h
   DRW_pbvh.h
@@ -297,6 +302,9 @@ set(SRC
   engines/select/select_private.h
   engines/overlay/overlay_engine.h
   engines/overlay/overlay_private.hh
+  engines/strokegen/strokegen_engine.h
+  engines/strokegen/strokegen_shader.hh
+  engines/strokegen/strokegen_instance.hh
 )
 
 set(LIB
diff --git a/source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh b/source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh
new file mode 100644
index 00000000000..e275d208c7a
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh
@@ -0,0 +1,65 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#include "gpu_shader_create_info.hh"
+
+/* -------------------------------------------------------------------- */
+/** \name Conservative Rasterization
+ *
+ * Allow selection of sub-pixel objects.
+ * \{ */
+
+GPU_SHADER_CREATE_INFO(basic_conservative)
+    .geometry_layout(PrimitiveIn::TRIANGLES, PrimitiveOut::TRIANGLE_STRIP, 3)
+    .geometry_source("basic_conservative_depth_geom.glsl");
+
+/** \} */
+
+/* -------------------------------------------------------------------- */
+/** \name Object types
+ * \{ */
+
+GPU_SHADER_CREATE_INFO(basic_mesh)
+    .vertex_in(0, Type::VEC3, "pos")
+    .vertex_source("basic_depth_vert.glsl")
+    .additional_info("draw_mesh");
+
+GPU_SHADER_CREATE_INFO(basic_pointcloud)
+    .vertex_source("basic_depth_pointcloud_vert.glsl")
+    .additional_info("draw_pointcloud");
+
+GPU_SHADER_CREATE_INFO(basic_curves)
+    .vertex_source("basic_depth_curves_vert.glsl")
+    .additional_info("draw_hair");
+/** \} */
+
+/* -------------------------------------------------------------------- */
+/** \name Variations Declaration
+ * \{ */
+
+#define BASIC_FINAL_VARIATION(name, ...) \
+  GPU_SHADER_CREATE_INFO(name).additional_info(__VA_ARGS__).do_static_compilation(true);
+
+#define BASIC_CLIPPING_VARIATIONS(prefix, ...) \
+  BASIC_FINAL_VARIATION(prefix##_clipped, "drw_clipped", __VA_ARGS__) \
+  BASIC_FINAL_VARIATION(prefix, __VA_ARGS__)
+
+#define BASIC_CONSERVATIVE_VARIATIONS(prefix, ...) \
+  BASIC_CLIPPING_VARIATIONS(prefix##_conservative, "basic_conservative", __VA_ARGS__) \
+  BASIC_CLIPPING_VARIATIONS(prefix, __VA_ARGS__)
+
+#define BASIC_OBTYPE_VARIATIONS(prefix, ...) \
+  BASIC_CONSERVATIVE_VARIATIONS(prefix##_mesh, "basic_mesh", __VA_ARGS__) \
+  BASIC_CONSERVATIVE_VARIATIONS(prefix##_pointcloud, "basic_pointcloud", __VA_ARGS__) \
+  BASIC_CLIPPING_VARIATIONS(prefix##_curves, "basic_curves", __VA_ARGS__)
+
+/** \} */
+
+/* -------------------------------------------------------------------- */
+/** \name Depth shader types.
+ * \{ */
+
+GPU_SHADER_CREATE_INFO(basic_depth).fragment_source("basic_depth_frag.glsl");
+
+BASIC_OBTYPE_VARIATIONS(basic_depth, "basic_depth", "draw_globals");
+
+/** \} */
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl
new file mode 100644
index 00000000000..b0da9754fc6
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl
@@ -0,0 +1,27 @@
+
+#pragma BLENDER_REQUIRE(common_hair_lib.glsl)
+#pragma BLENDER_REQUIRE(common_view_clipping_lib.glsl)
+#pragma BLENDER_REQUIRE(common_view_lib.glsl)
+
+void main()
+{
+  GPU_INTEL_VERTEX_SHADER_WORKAROUND
+
+  bool is_persp = (ProjectionMatrix[3][3] == 0.0);
+  float time, thick_time, thickness;
+  vec3 world_pos, tan, binor;
+  hair_get_pos_tan_binor_time(is_persp,
+                              ModelMatrixInverse,
+                              ViewMatrixInverse[3].xyz,
+                              ViewMatrixInverse[2].xyz,
+                              world_pos,
+                              tan,
+                              binor,
+                              time,
+                              thickness,
+                              thick_time);
+
+  gl_Position = point_world_to_ndc(world_pos);
+
+  view_clipping_distances(world_pos);
+}
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl
new file mode 100644
index 00000000000..ff4a015c335
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl
@@ -0,0 +1,5 @@
+
+void main()
+{
+  /* Passthrough shader. */
+}
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl
new file mode 100644
index 00000000000..b82edc61cee
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl
@@ -0,0 +1,15 @@
+
+#pragma BLENDER_REQUIRE(common_view_clipping_lib.glsl)
+#pragma BLENDER_REQUIRE(common_view_lib.glsl)
+#pragma BLENDER_REQUIRE(common_pointcloud_lib.glsl)
+
+void main()
+{
+  GPU_INTEL_VERTEX_SHADER_WORKAROUND
+
+  vec3 world_pos = pointcloud_get_pos();
+
+  gl_Position = point_world_to_ndc(world_pos);
+
+  view_clipping_distances(world_pos);
+}
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl
new file mode 100644
index 00000000000..7046979cf97
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl
@@ -0,0 +1,14 @@
+
+#pragma BLENDER_REQUIRE(common_view_clipping_lib.glsl)
+#pragma BLENDER_REQUIRE(common_view_lib.glsl)
+
+void main()
+{
+  GPU_INTEL_VERTEX_SHADER_WORKAROUND
+
+  vec3 world_pos = point_object_to_world(pos);
+
+  gl_Position = point_world_to_ndc(world_pos);
+
+  view_clipping_distances(world_pos);
+}
diff --git a/source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl b/source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl
new file mode 100644
index 00000000000..73b171e5cb6
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl
@@ -0,0 +1,51 @@
+#pragma BLENDER_REQUIRE(common_view_clipping_lib.glsl)
+#pragma BLENDER_REQUIRE(common_view_lib.glsl)
+
+/* Adaptation of Conservative Rasterization
+ * from GPU Gems 2
+ * Using method 2.
+ *
+ * Actual final implementation does not do conservative rasterization and only
+ * avoids triangles producing no fragments.
+ */
+
+void main()
+{
+  /* Compute plane normal in NDC space. */
+  vec3 pos0 = gl_in[0].gl_Position.xyz / gl_in[0].gl_Position.w;
+  vec3 pos1 = gl_in[1].gl_Position.xyz / gl_in[1].gl_Position.w;
+  vec3 pos2 = gl_in[2].gl_Position.xyz / gl_in[2].gl_Position.w;
+  vec3 plane = normalize(cross(pos1 - pos0, pos2 - pos0));
+  /* Compute NDC bound box. */
+  vec4 bbox = vec4(min(min(pos0.xy, pos1.xy), pos2.xy), max(max(pos0.xy, pos1.xy), pos2.xy));
+  /* Convert to pixel space. */
+  bbox = (bbox * 0.5 + 0.5) * sizeViewport.xyxy;
+  /* Detect failure cases where triangles would produce no fragments. */
+  bvec2 is_subpixel = lessThan(bbox.zw - bbox.xy, vec2(1.0));
+  /* View aligned triangle. */
+  const float threshold = 0.00001;
+  bool is_coplanar = abs(plane.z) < threshold;
+
+  for (int i = 0; i < 3; i++) {
+    gl_Position = gl_in[i].gl_Position;
+    if (all(is_subpixel)) {
+      vec2 ofs = (i == 0) ? vec2(-1.0) : ((i == 1) ? vec2(2.0, -1.0) : vec2(-1.0, 2.0));
+      /* HACK: Fix cases where the triangle is too small make it cover at least one pixel. */
+      gl_Position.xy += sizeViewportInv * gl_Position.w * ofs;
+    }
+    /* Test if the triangle is almost parallel with the view to avoid precision issues. */
+    else if (any(is_subpixel) || is_coplanar) {
+      /* HACK: Fix cases where the triangle is Parallel to the view by deforming it slightly. */
+      vec2 ofs = (i == 0) ? vec2(-1.0) : ((i == 1) ? vec2(1.0, -1.0) : vec2(1.0));
+      gl_Position.xy += sizeViewportInv * gl_Position.w * ofs;
+    }
+    else {
+      /* Triangle expansion should happen here, but we decide to not implement it for
+       * depth precision & performance reasons. */
+    }
+
+    view_clipping_distances_set(gl_in[i]);
+    EmitVertex();
+  }
+  EndPrimitive();
+}
diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.cc b/source/blender/draw/engines/strokegen/strokegen_engine.cc
new file mode 100644
index 00000000000..b4267ce42f5
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_engine.cc
@@ -0,0 +1,413 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later
+ * Copyright 2016 Blender Foundation. */
+
+/** \file
+ * \ingroup draw_engine
+ *
+ * Simple engine for drawing color and/or depth.
+ * When we only need simple flat shaders.
+ */
+
+#include "DRW_render.h"
+
+#include "BKE_object.h"
+#include "BKE_paint.h"
+
+#include "BLI_alloca.h"
+
+#include "GPU_shader.h"
+
+#include "strokegen_engine.h"
+
+#include "strokegen_instance.hh"
+#include "strokegen_shader.hh"
+
+
+using namespace blender;
+
+
+
+#define STROKEGEN_ENGINE "BLENDER_STROKEGEN"
+
+/* *********** LISTS *********** */
+
+/* GPUViewport.storage
+ * Is freed every time the viewport engine changes. */
+typedef struct STROKEGEN_StorageList {
+  struct STROKEGEN_PrivateData *g_data;
+} STROKEGEN_StorageList;
+
+typedef struct STROKEGEN_PassList {
+  struct DRWPass *depth_pass[2];
+  struct DRWPass *depth_pass_pointcloud[2];
+  struct DRWPass *depth_pass_cull[2];
+} STROKEGEN_PassList;
+
+// Per-engine data
+// Sent by draw manager to the draw-engine.
+typedef struct STROKEGEN_Data {
+  void *engine_type;
+  DRWViewportEmptyList *fbl;
+  DRWViewportEmptyList *txl;
+  STROKEGEN_PassList *psl;
+  STROKEGEN_StorageList *stl;
+
+  strokegen::Instance *instance;
+  char info[GPU_INFO_SIZE];
+
+} STROKEGEN_Data;
+
+/* *********** STATIC *********** */
+
+typedef struct STROKEGEN_PrivateData {
+  DRWShadingGroup *depth_shgrp[2];
+  DRWShadingGroup *depth_shgrp_cull[2];
+  DRWShadingGroup *depth_hair_shgrp[2];
+  DRWShadingGroup *depth_curves_shgrp[2];
+  DRWShadingGroup *depth_pointcloud_shgrp[2];
+  bool use_material_slot_selection;
+} STROKEGEN_PrivateData; /* Transient data */
+
+
+
+static bool check_strokegen_support()
+{
+  return GPU_shader_storage_buffer_objects_support();
+}
+
+
+static void strokegen_engine_init(void *vedata)
+{
+  if (!check_strokegen_support()) { return; }
+
+  STROKEGEN_Data *ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
+  if (ved->instance == nullptr) {
+    ved->instance = new strokegen::Instance();
+  }
+
+  const DRWContextState *ctx_state = DRW_context_state_get();
+  ved->instance->init(ctx_state->depsgraph, ctx_state->v3d);
+}
+
+
+
+static void strokegen_draw_scene_legacy(void *vedata)
+{
+  STROKEGEN_PassList *psl = ((STROKEGEN_Data *)vedata)->psl;
+
+  DRW_draw_pass(psl->depth_pass[0]);
+  DRW_draw_pass(psl->depth_pass_pointcloud[0]);
+  DRW_draw_pass(psl->depth_pass_cull[0]);
+  DRW_draw_pass(psl->depth_pass[1]);
+  DRW_draw_pass(psl->depth_pass_pointcloud[1]);
+  DRW_draw_pass(psl->depth_pass_cull[1]);
+}
+
+static void strokegen_draw_scene(void *vedata)
+{
+  STROKEGEN_Data *ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
+  if (!check_strokegen_support()) {
+    STRNCPY(ved->info, "Error: No shader storage buffer support, required by StrokeGen.");
+    return;
+  }
+
+
+  // TODO: not sure which is better, frame-buffer or texture list?
+  // DefaultFramebufferList *dfbl = DRW_viewport_framebuffer_list_get();
+  DefaultTextureList *dtxl = DRW_viewport_texture_list_get();
+
+  const DRWView *default_view = DRW_view_default_get();
+  draw::Manager *manager = DRW_manager_get();
+  draw::View view("DefaultView", default_view);
+  ved->instance->draw_viewport(*manager, view, dtxl->depth, dtxl->color);
+
+
+  strokegen_draw_scene_legacy(vedata);
+
+
+  /* Reset view for other following engines. */
+  DRW_view_set_active(nullptr);
+}
+
+
+
+
+static void strokegen_cache_init_legacy(void *vedata)
+{
+  STROKEGEN_PassList *psl = static_cast<STROKEGEN_Data*>(vedata)->psl;
+  STROKEGEN_StorageList *stl = static_cast<STROKEGEN_Data*>(vedata)->stl;
+  DRWShadingGroup *grp;
+
+  const DRWContextState *draw_ctx = DRW_context_state_get();
+
+  if (!stl->g_data) {
+    /* Alloc transient pointers */
+    stl->g_data = (STROKEGEN_PrivateData* )MEM_callocN(sizeof(*stl->g_data), __func__);
+  }
+
+  stl->g_data->use_material_slot_selection = DRW_state_is_material_select();
+
+  /* Twice for normal and in front objects. */
+  for (int i = 0; i < 2; i++) {
+    DRWState clip_state = static_cast<DRWState>(
+      (draw_ctx->sh_cfg == GPU_SHADER_CFG_CLIPPED) ? DRW_STATE_CLIP_PLANES : 0
+    );
+    DRWState infront_state = static_cast<DRWState>(
+      (DRW_state_is_select() && (i == 1)) ? DRW_STATE_IN_FRONT_SELECT : 0
+    );
+    DRWState state = DRW_STATE_WRITE_DEPTH | DRW_STATE_DEPTH_LESS_EQUAL;
+
+    blender::strokegen::ShaderModule* shaderModule =
+      blender::strokegen::ShaderModule::module_get();
+
+    GPUShader *sh = DRW_state_is_select() ?
+                        shaderModule->static_shader_get(blender::strokegen::DEPTH_CONSERVATIVE) :
+                        shaderModule->static_shader_get(blender::strokegen::DEPTH);
+
+    DRW_PASS_CREATE(psl->depth_pass[i], state | clip_state | infront_state);
+    stl->g_data->depth_shgrp[i] = grp = DRW_shgroup_create(sh, psl->depth_pass[i]);
+    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+
+    sh = DRW_state_is_select() ?
+        shaderModule->static_shader_get(blender::strokegen::POINTCLOUD_DEPTH_CONSERVATIVE) :
+        shaderModule->static_shader_get(blender::strokegen::POINTCLOUD_DEPTH);
+    DRW_PASS_CREATE(psl->depth_pass_pointcloud[i], state | clip_state | infront_state);
+    stl->g_data->depth_pointcloud_shgrp[i] = grp = DRW_shgroup_create(
+        sh, psl->depth_pass_pointcloud[i]);
+    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+
+    stl->g_data->depth_hair_shgrp[i] = grp = DRW_shgroup_create(
+        shaderModule->static_shader_get(blender::strokegen::DEPTH), psl->depth_pass[i]);
+    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+
+    stl->g_data->depth_curves_shgrp[i] = grp = DRW_shgroup_create(
+        shaderModule->static_shader_get(blender::strokegen::CURVES_DEPTH), psl->depth_pass[i]);
+    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+
+    sh = DRW_state_is_select() ? shaderModule->static_shader_get(blender::strokegen::DEPTH_CONSERVATIVE) :
+                                 shaderModule->static_shader_get(blender::strokegen::DEPTH);
+    state |= DRW_STATE_CULL_BACK;
+    DRW_PASS_CREATE(psl->depth_pass_cull[i], state | clip_state | infront_state);
+    stl->g_data->depth_shgrp_cull[i] = grp = DRW_shgroup_create(sh, psl->depth_pass_cull[i]);
+    DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
+  }
+}
+static void strokegen_cache_init(void *vedata)
+{
+  if (!check_strokegen_support()) return;
+
+  draw::Manager* drwmgr = DRW_manager_get();
+  reinterpret_cast<STROKEGEN_Data *>(vedata)->instance->begin_sync(*drwmgr);
+
+
+  strokegen_cache_init_legacy(vedata);
+}
+
+
+
+
+
+
+
+
+
+/* TODO(fclem): DRW_cache_object_surface_material_get needs a refactor to allow passing NULL
+ * instead of gpumat_array. Avoiding all this boilerplate code. */
+static struct GPUBatch **strokegen_object_surface_material_get(Object *ob)
+{
+  const int materials_len = DRW_cache_object_material_count_get(ob);
+  struct GPUMaterial **gpumat_array =
+    static_cast<GPUMaterial**>(BLI_array_alloca(gpumat_array, materials_len));
+  memset(gpumat_array, 0, sizeof(*gpumat_array) * materials_len);
+
+  return DRW_cache_object_surface_material_get(ob, gpumat_array, materials_len);
+}
+
+static void strokegen_cache_populate_particles(void *vedata, Object *ob)
+{
+  // do nothing here.
+}
+
+static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
+{
+  STROKEGEN_StorageList *stl = ((STROKEGEN_Data *)vedata)->stl;
+
+  /* TODO(fclem): fix selection of smoke domains. */
+
+  if (!DRW_object_is_renderable(ob) || (ob->dt < OB_SOLID)) {
+    return;
+  }
+
+  const DRWContextState *draw_ctx = DRW_context_state_get();
+  if (ob != draw_ctx->object_edit) {
+    strokegen_cache_populate_particles(vedata, ob);
+  }
+
+  const bool do_in_front = (ob->dtx & OB_DRAW_IN_FRONT) != 0;
+  if (ob->type == OB_CURVES) {
+    DRW_shgroup_curves_create_sub(ob, stl->g_data->depth_curves_shgrp[do_in_front], NULL);
+  }
+
+  /* Make flat object selectable in ortho view if wireframe is enabled. */
+  if ((draw_ctx->v3d->overlay.flag & V3D_OVERLAY_WIREFRAMES) ||
+      (draw_ctx->v3d->shading.type == OB_WIRE) || (ob->dtx & OB_DRAWWIRE) || (ob->dt == OB_WIRE)) {
+    int flat_axis = 0;
+    bool is_flat_object_viewed_from_side = ((draw_ctx->rv3d->persp == RV3D_ORTHO) &&
+                                            DRW_object_is_flat(ob, &flat_axis) &&
+                                            DRW_object_axis_orthogonal_to_view(ob, flat_axis));
+
+    if (is_flat_object_viewed_from_side) {
+      /* Avoid losing flat objects when in ortho views (see T56549) */
+      struct GPUBatch *geom = DRW_cache_object_all_edges_get(ob);
+      if (geom) {
+        DRW_shgroup_call(stl->g_data->depth_shgrp[do_in_front], geom, ob);
+      }
+      return;
+    }
+  }
+
+  const bool use_sculpt_pbvh = BKE_sculptsession_use_pbvh_draw(ob, draw_ctx->rv3d) &&
+                               !DRW_state_is_image_render();
+  const bool do_cull = (draw_ctx->v3d &&
+                        (draw_ctx->v3d->shading.flag & V3D_SHADING_BACKFACE_CULLING));
+
+  DRWShadingGroup *shgrp = NULL;
+
+  if (ob->type == OB_POINTCLOUD) {
+    shgrp = stl->g_data->depth_pointcloud_shgrp[do_in_front];
+  }
+  else {
+    shgrp = (do_cull) ? stl->g_data->depth_shgrp_cull[do_in_front] :
+                        stl->g_data->depth_shgrp[do_in_front];
+  }
+
+  if (use_sculpt_pbvh) {
+    DRW_shgroup_call_sculpt(shgrp, ob, false, false, false, false, false);
+  }
+  else {
+    if (stl->g_data->use_material_slot_selection && BKE_object_supports_material_slots(ob)) {
+      struct GPUBatch **geoms = strokegen_object_surface_material_get(ob);
+      if (geoms) {
+        const int materials_len = DRW_cache_object_material_count_get(ob);
+        for (int i = 0; i < materials_len; i++) {
+          if (geoms[i] == NULL) {
+            continue;
+          }
+          const short material_slot_select_id = i + 1;
+          DRW_select_load_id(ob->runtime.select_id | (material_slot_select_id << 16));
+          DRW_shgroup_call(shgrp, geoms[i], ob);
+        }
+      }
+    }
+    else {
+      struct GPUBatch *geom = DRW_cache_object_surface_get(ob);
+      if (geom) {
+        DRW_shgroup_call(shgrp, geom, ob);
+      }
+    }
+  }
+}
+static void strokegen_cache_populate(void *vedata, Object *object)
+{
+  if (!check_strokegen_support()) return;
+
+  STROKEGEN_Data* ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
+
+  draw::Manager* drw_mgr = DRW_manager_get();
+  draw::ObjectRef ref {
+    object,
+    DRW_object_get_dupli(object),
+    DRW_object_get_dupli_parent(object)
+  };
+
+  ved->instance->object_sync(*drw_mgr, ref);
+
+
+
+  strokegen_cache_populate_legacy(vedata, object);
+}
+
+
+static void strokegen_cache_finish_legacy(void *vedata)
+{
+  STROKEGEN_StorageList *stl = ((STROKEGEN_Data *)vedata)->stl;
+
+  UNUSED_VARS(stl);
+}
+static void strokegen_cache_finish(void *vedata)
+{
+  if (!check_strokegen_support()) return;
+
+  STROKEGEN_Data* ved = reinterpret_cast<STROKEGEN_Data*>(vedata);
+  draw::Manager* drw_mgr = DRW_manager_get();
+
+  ved->instance->end_sync(*drw_mgr);
+
+
+
+  strokegen_cache_finish_legacy(vedata);
+}
+
+static void strokegen_instance_free(void *instance) {
+  if (!GPU_shader_storage_buffer_objects_support()) {
+    return;
+  }
+  delete reinterpret_cast<strokegen::Instance *>(instance);
+}
+
+static void strokegen_engine_free(void)
+{
+  strokegen::ShaderModule::module_free();
+}
+
+static void strokegen_render_to_image(void *vedata, struct RenderEngine *engine,
+                                    struct RenderLayer *layer,
+                                    const struct rcti *UNUSED(rect)) {
+  UNUSED_VARS(vedata, engine, layer);
+}
+
+
+
+
+
+
+static const DrawEngineDataSize strokegen_data_size = DRW_VIEWPORT_DATA_SIZE(STROKEGEN_Data);
+
+DrawEngineType draw_engine_strokegen_type = {
+    NULL,
+    NULL,
+    N_("StrokeGen"),
+    &strokegen_data_size,
+    strokegen_engine_init,
+    &strokegen_engine_free,
+    &strokegen_instance_free,
+    &strokegen_cache_init,
+    &strokegen_cache_populate,
+    &strokegen_cache_finish,
+    &strokegen_draw_scene,
+    NULL,
+    NULL,
+    strokegen_render_to_image,
+    NULL,
+};
+
+RenderEngineType DRW_engine_viewport_strokegen_type = {
+  nullptr,
+  nullptr,
+  "STROKEGEN_VIEW",
+  N_("strokegen"),
+  RE_INTERNAL | RE_USE_PREVIEW | RE_USE_STEREO_VIEWPORT | RE_USE_GPU_CONTEXT,
+  nullptr,
+  &DRW_render_to_image,
+  nullptr,
+  nullptr,
+  nullptr,
+  nullptr,
+  nullptr,
+  nullptr,
+  nullptr, // TODO: impl this
+  &draw_engine_strokegen_type,
+  {nullptr, nullptr, nullptr},
+};
+
+#undef STROKEGEN_ENGINE
diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.h b/source/blender/draw/engines/strokegen/strokegen_engine.h
new file mode 100644
index 00000000000..0df3623e738
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_engine.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later
+ * Copyright 2016 Blender Foundation. */
+
+/** \file
+ * \ingroup draw_engine
+ */
+
+#pragma once
+
+#include "DRW_render.h"
+#include "RE_engine.h"
+
+#ifdef __cplusplus
+extern "C" { // to satisfy .cc files
+#endif
+
+extern DrawEngineType draw_engine_strokegen_type;
+extern RenderEngineType DRW_engine_viewport_strokegen_type;
+
+// Also I spent some time reading the mesh extraction code,
+// feel like I could add one or more new mesh buffers & extractors?
+// In that way,
+// 1) Never need to touch the DNA data;
+// 2) DrawManager updates these buffers when populates caches for the DrawEngine;
+// 3) DrawEngine uses a eevee-next-style sync module, in its function "sync_mesh":
+// -- 3.1) duplicate a ref from the cache, and
+// -- 3.2) issue ordered compute dispatches & indirect procedural draws;
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.cc b/source/blender/draw/engines/strokegen/strokegen_instance.cc
new file mode 100644
index 00000000000..377dd9a11ef
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_instance.cc
@@ -0,0 +1,29 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup strokegen
+ *
+ * An instance contains all structures needed to do a complete render.
+ */
+
+#include <sstream>
+
+#include "BKE_global.h"
+#include "BKE_object.h"
+#include "BLI_rect.h"
+#include "DEG_depsgraph_query.h"
+#include "DNA_ID.h"
+#include "DNA_lightprobe_types.h"
+#include "DNA_modifier_types.h"
+#include "RE_pipeline.h"
+
+#include "strokegen_instance.hh"
+
+namespace blender::strokegen
+{
+
+  
+
+}
diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.hh b/source/blender/draw/engines/strokegen/strokegen_instance.hh
new file mode 100644
index 00000000000..6944f5baa7e
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_instance.hh
@@ -0,0 +1,75 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup strokegen
+ *
+ * An renderer instance that contains all data to render a full frame.
+*/
+
+#pragma once
+
+#include "BKE_image.h"
+#include "DEG_depsgraph_query.h"
+#include "DNA_shader_fx_types.h"
+#include "DRW_engine.h"
+#include "DRW_render.h"
+#include "ED_view3d.h"
+#include "GPU_capabilities.h"
+#include "IMB_imbuf_types.h"
+
+#include "draw_manager.hh"
+#include "draw_pass.hh"
+#include "strokegen_shader.hh"
+
+
+namespace blender::strokegen
+{
+  using namespace draw;
+
+  class Instance
+  {
+  private:
+
+
+  public:
+    Instance() : shaders(*ShaderModule::module_get())
+    {
+    };
+
+    void init(Depsgraph* depsgraph, View3D* v3d)
+    {
+      /* Init things static per render frame. (Not render graph related) */
+    }
+
+    void begin_sync(Manager& /* manager */)
+    {
+      /* Init draw passes and manager related stuff. (Begin render graph) */
+    }
+
+    void object_sync(Manager& manager, ObjectRef& object_ref)
+    {
+      /* Add object draw calls to passes. (Populate render graph) */
+    }
+
+    void end_sync(Manager& /* manager */)
+    {
+      /* Post processing after all object. (End render graph) */
+    }
+
+    void draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
+                       GPUTexture* color_tx)
+    {
+      /* Submit passes here. (Execute render graph) */
+    }
+
+
+
+    ShaderModule shaders; // singleton class for handling GPUShader(s)
+
+
+  };
+}
+
+
diff --git a/source/blender/draw/engines/strokegen/strokegen_shader.cc b/source/blender/draw/engines/strokegen/strokegen_shader.cc
new file mode 100644
index 00000000000..efe37087ef0
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_shader.cc
@@ -0,0 +1,119 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+ * Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup eevee
+ *
+ * Shader module that manage shader libraries, deferred compilation,
+ * and static shader usage.
+ */
+
+#include "GPU_capabilities.h"
+
+#include "gpu_shader_create_info.hh"
+
+#include "strokegen_shader.hh"
+
+namespace blender::strokegen {
+
+/* -------------------------------------------------------------------- */
+/** \name Module
+ *
+ * \{ */
+
+ShaderModule *ShaderModule::g_shader_module = nullptr;
+
+ShaderModule *ShaderModule::module_get()
+{
+  if (g_shader_module == nullptr) {
+    /* TODO(@fclem) thread-safety. */
+    g_shader_module = new ShaderModule();
+  }
+  return g_shader_module;
+}
+
+void ShaderModule::module_free()
+{
+  if (g_shader_module != nullptr) {
+    /* TODO(@fclem) thread-safety. */
+    delete g_shader_module;
+    g_shader_module = nullptr;
+  }
+}
+
+ShaderModule::ShaderModule()
+{
+  for (GPUShader *&shader : shaders_) {
+    shader = nullptr;
+  }
+
+#ifdef DEBUG
+  /* Ensure all shader are described. */
+  for (auto i : IndexRange(MAX_SHADER_TYPE)) {
+    const char *name = static_shader_create_info_name_get(eShaderType(i));
+    if (name == nullptr) {
+      std::cerr << "STROKEGEN: Missing case for eShaderType(" << i
+                << ") in static_shader_create_info_name_get().";
+      BLI_assert(0);
+    }
+    const GPUShaderCreateInfo *create_info = GPU_shader_create_info_get(name);
+    BLI_assert_msg(create_info != nullptr, "STROKEGEN: Missing create info for static shader.");
+  }
+#endif
+}
+
+ShaderModule::~ShaderModule()
+{
+  for (GPUShader *&shader : shaders_) {
+    DRW_SHADER_FREE_SAFE(shader);
+  }
+}
+
+/** \} */
+
+/* -------------------------------------------------------------------- */
+/** \name Static shaders
+ *
+ * \{ */
+
+const char *ShaderModule::static_shader_create_info_name_get(eShaderType shader_type)
+{
+  switch (shader_type) {
+    case DEPTH:
+      return "basic_depth_mesh";
+    case POINTCLOUD_DEPTH:
+      return "basic_depth_pointcloud";
+    case CURVES_DEPTH:
+      return "basic_depth_curves";
+    case DEPTH_CONSERVATIVE:
+      return "basic_depth_mesh_conservative";
+    case POINTCLOUD_DEPTH_CONSERVATIVE:
+      return "basic_depth_pointcloud_conservative";
+
+    /* To avoid compiler warning about missing case. */
+    case MAX_SHADER_TYPE:
+      return "";
+  }
+  return "";
+}
+
+GPUShader *ShaderModule::static_shader_get(eShaderType shader_type)
+{
+  if (shaders_[shader_type] == nullptr) {
+    const char *shader_name = static_shader_create_info_name_get(shader_type);
+
+    shaders_[shader_type] = GPU_shader_create_from_info_name(shader_name);
+
+    if (shaders_[shader_type] == nullptr) {
+      fprintf(stderr, "STROKEGEN: error: Could not compile static shader \"%s\"\n", shader_name);
+    }
+    BLI_assert(shaders_[shader_type] != nullptr);
+  }
+  return shaders_[shader_type];
+}
+
+
+/** \} */
+
+}  // namespace blender::strokegen
diff --git a/source/blender/draw/engines/strokegen/strokegen_shader.hh b/source/blender/draw/engines/strokegen/strokegen_shader.hh
new file mode 100644
index 00000000000..92f8e90a4fe
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_shader.hh
@@ -0,0 +1,62 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+ * Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup strokegen
+ *
+ * Shader module that manage shader libraries, deferred compilation,
+ * and static shader usage.
+ */
+
+#pragma once
+
+#include <array>
+#include <string>
+
+#include "BLI_string_ref.hh"
+#include "DRW_render.h"
+#include "GPU_material.h"
+#include "GPU_shader.h"
+
+
+namespace blender::strokegen {
+
+/* Keep alphabetical order and clean prefix. */
+enum eShaderType {
+  DEPTH = 0,
+  POINTCLOUD_DEPTH,
+  CURVES_DEPTH,
+  DEPTH_CONSERVATIVE,
+  POINTCLOUD_DEPTH_CONSERVATIVE,
+
+  MAX_SHADER_TYPE,
+};
+
+/**
+ * Shader module. shared between instances.
+ */
+class ShaderModule {
+ private:
+  std::array<GPUShader *, MAX_SHADER_TYPE> shaders_;
+
+  /** Shared shader module across all engine instances. */
+  static ShaderModule *g_shader_module;
+
+ public:
+  ShaderModule();
+  ~ShaderModule();
+
+  GPUShader *static_shader_get(eShaderType shader_type);
+  // TODO: GPUMaterial ? (see impl in eevee)
+
+
+  /** Only to be used by Instance constructor. */
+  static ShaderModule *module_get();
+  static void module_free();
+
+ private:
+  const char *static_shader_create_info_name_get(eShaderType shader_type);
+};
+
+}  // namespace blender::strokegen
diff --git a/source/blender/draw/intern/draw_manager.c b/source/blender/draw/intern/draw_manager.c
index 9e939fb490f..d10488abc22 100644
--- a/source/blender/draw/intern/draw_manager.c
+++ b/source/blender/draw/intern/draw_manager.c
@@ -96,6 +96,7 @@
 #include "engines/overlay/overlay_engine.h"
 #include "engines/select/select_engine.h"
 #include "engines/workbench/workbench_engine.h"
+#include "engines/strokegen/strokegen_engine.h"
 
 #include "GPU_context.h"
 
@@ -3000,6 +3001,7 @@ void DRW_engines_register(void)
 {
   RE_engines_register(&DRW_engine_viewport_eevee_type);
   RE_engines_register(&DRW_engine_viewport_workbench_type);
+  RE_engines_register(&DRW_engine_viewport_strokegen_type);
 
   DRW_engine_register(&draw_engine_gpencil_type);
 
@@ -3014,6 +3016,8 @@ void DRW_engines_register(void)
   DRW_engine_register(&draw_engine_image_type);
   DRW_engine_register(DRW_engine_viewport_external_type.draw_engine);
 
+  DRW_engine_register(&draw_engine_strokegen_type);
+
   /* setup callbacks */
   {
     BKE_curve_batch_cache_dirty_tag_cb = DRW_curve_batch_cache_dirty_tag;
-- 
2.38.1.windows.1


From 7b90c17f692386326aefcb707583c09e773532c9 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sat, 3 Dec 2022 18:11:57 +0800
Subject: [PATCH 02/11] Basic data members

Decl & Init for basic data members of strokegen::Instance.
---
 .../engines/strokegen/strokegen_engine.cc     | 24 ++++-
 .../engines/strokegen/strokegen_instance.cc   | 89 ++++++++++++++++++-
 .../engines/strokegen/strokegen_instance.hh   | 57 +++++++-----
 3 files changed, 146 insertions(+), 24 deletions(-)

diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.cc b/source/blender/draw/engines/strokegen/strokegen_engine.cc
index b4267ce42f5..56b3b170660 100644
--- a/source/blender/draw/engines/strokegen/strokegen_engine.cc
+++ b/source/blender/draw/engines/strokegen/strokegen_engine.cc
@@ -85,8 +85,26 @@ static void strokegen_engine_init(void *vedata)
     ved->instance = new strokegen::Instance();
   }
 
+  draw::Manager *drw_mgr = DRW_manager_get();
+
   const DRWContextState *ctx_state = DRW_context_state_get();
-  ved->instance->init(ctx_state->depsgraph, ctx_state->v3d);
+  View3D *v3d = ctx_state->v3d;
+  RegionView3D *rv3d = ctx_state->rv3d;
+
+  Object *camera = nullptr;
+  if (v3d && rv3d && rv3d->persp == RV3D_CAMOB)
+    camera = v3d->camera;
+
+  const DRWView* default_drw_view = DRW_view_default_get();
+
+
+  ved->instance->init(
+    ctx_state->depsgraph,
+    drw_mgr,
+    ctx_state->v3d, rv3d,
+    default_drw_view,
+    camera
+  );
 }
 
 
@@ -119,7 +137,11 @@ static void strokegen_draw_scene(void *vedata)
   const DRWView *default_view = DRW_view_default_get();
   draw::Manager *manager = DRW_manager_get();
   draw::View view("DefaultView", default_view);
+  // draw passes
   ved->instance->draw_viewport(*manager, view, dtxl->depth, dtxl->color);
+  // display error msg at the top of the render viewport
+  STRNCPY(ved->info, ved->instance->info.c_str());
+
 
 
   strokegen_draw_scene_legacy(vedata);
diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.cc b/source/blender/draw/engines/strokegen/strokegen_instance.cc
index 377dd9a11ef..74037bf3b76 100644
--- a/source/blender/draw/engines/strokegen/strokegen_instance.cc
+++ b/source/blender/draw/engines/strokegen/strokegen_instance.cc
@@ -23,7 +23,94 @@
 
 namespace blender::strokegen
 {
+  /* -------------------------------------------------------------------- */
+  /** \name Initialization
+   *
+   * Initialization functions need to be called once at the start of a frame.
+   * Active camera, render extent and enabled render passes are immutable until next init.
+   * This takes care of resizing output buffers and view in case a parameter changed.
+   * IMPORTANT: xxx.init() functions are NOT meant to acquire and allocate DRW resources.
+   * Any attempt to do so will likely produce use after free situations.
+   * \{ */
+  void Instance::init(
+    Depsgraph* depsgraph_,
+    Manager* manager_,
+    const View3D* v3d_,
+    const RegionView3D* rv3d_,
+    const DRWView* drw_view_,
+    Object* camera_object_)
+  {
+    /* Init things static per render frame. (Not render graph related) */
+    depsgraph = depsgraph_;
+    manager = manager_;
+
+    drw_view = drw_view_;
+    v3d = v3d_;
+    rv3d = rv3d_;
+
+    camera_orig_object = camera_object_;
+
+    info = "";
+  }
+
+  void Instance::update_eval_members()
+  {
+    scene = DEG_get_evaluated_scene(depsgraph);
+    camera_eval_object = (camera_orig_object) ?
+                         DEG_get_evaluated_object(depsgraph, camera_orig_object) :
+                         nullptr;
+  }
+
+  /** \} */
+
+
+
+
+
+
+  /* -------------------------------------------------------------------- */
+  /** \name Sync
+   *
+   * Sync will gather data from the scene that can change over a time step (i.e: motion steps).
+   * IMPORTANT: xxx.sync() functions area responsible for creating DRW resources (i.e: DRWView) as
+   * well as querying temp texture pool. All DRWPasses should be ready by the end end_sync().
+   * \{ */
+  void Instance::begin_sync(Manager& manager)
+  {
+    /* Init draw passes and manager related stuff. (Begin render graph) */
+  }
+
+  void Instance::object_sync(Manager& manager, ObjectRef& object_ref)
+  {
+    /* Add object draw calls to passes. (Populate render graph) */
+  }
+
+  void Instance::end_sync(Manager&)
+  {
+    /* Post processing after all object. (End render graph) */
+  }
+
+  /** \} */
+
+
+
+
+
+
+  /* -------------------------------------------------------------------- */
+  /** \name Rendering
+   * \{ */
+
+  void Instance::draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
+    GPUTexture* color_tx)
+  {
+    /* Submit passes here. (Execute render graph) */
+  }
+
+  /** \} */
+
+
+
 
-  
 
 }
diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.hh b/source/blender/draw/engines/strokegen/strokegen_instance.hh
index 6944f5baa7e..ac1332c5838 100644
--- a/source/blender/draw/engines/strokegen/strokegen_instance.hh
+++ b/source/blender/draw/engines/strokegen/strokegen_instance.hh
@@ -32,42 +32,55 @@ namespace blender::strokegen
   {
   private:
 
+  public:
+    /** Shading Modules */
+    ShaderModule shaders; // singleton class for handling GPUShader(s)
+
+
+    /** Input data. */
+    Depsgraph *depsgraph;
+    Manager *manager;
+
+    /** Evaluated IDs. */
+    Scene *scene;
+    Object *camera_eval_object;
+    Object *camera_orig_object;
+    /** Only available when rendering for viewport. */
+    const DRWView *drw_view;
+    const View3D *v3d;
+    const RegionView3D *rv3d;
+
+
+
+
+
+    /** Info string displayed at the top of the render / viewport. */
+    std::string info = "";
+    /** Debug mode from debug value. */
+    // eDebugMode debug_mode = eDebugMode::DEBUG_NONE;
+
+
 
   public:
     Instance() : shaders(*ShaderModule::module_get())
     {
     };
 
-    void init(Depsgraph* depsgraph, View3D* v3d)
-    {
-      /* Init things static per render frame. (Not render graph related) */
-    }
+    void init(Depsgraph* depsgraph_, draw::Manager* manager_, const View3D* v3d_, const RegionView3D* rv3d_, const
+              DRWView* drw_view_, Object* camera_object_);
+    void update_eval_members();
 
-    void begin_sync(Manager& /* manager */)
-    {
-      /* Init draw passes and manager related stuff. (Begin render graph) */
-    }
+    void begin_sync(Manager& manager);
 
-    void object_sync(Manager& manager, ObjectRef& object_ref)
-    {
-      /* Add object draw calls to passes. (Populate render graph) */
-    }
+    void object_sync(Manager& manager, ObjectRef& object_ref);
 
-    void end_sync(Manager& /* manager */)
-    {
-      /* Post processing after all object. (End render graph) */
-    }
+    void end_sync(Manager& /* manager */);
 
     void draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
-                       GPUTexture* color_tx)
-    {
-      /* Submit passes here. (Execute render graph) */
-    }
+                       GPUTexture* color_tx);
 
 
 
-    ShaderModule shaders; // singleton class for handling GPUShader(s)
-
 
   };
 }
-- 
2.38.1.windows.1


From 15803b42819ff5659c6a9b79ce6e05c7c0d4f386 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sat, 3 Dec 2022 19:08:34 +0800
Subject: [PATCH 03/11] Basic setup for strokegen_sync

Basic calls for sync module, all empty func for now.
Also structs for reference object/resources in scene, copied from eevee_sync.hh
---
 source/blender/draw/CMakeLists.txt            |   5 +
 .../engines/strokegen/strokegen_defines.hh    |  10 +
 .../engines/strokegen/strokegen_instance.hh   |   7 +-
 .../strokegen/strokegen_shader_shared.hh      |   7 +
 .../draw/engines/strokegen/strokegen_sync.cc  |  29 +++
 .../draw/engines/strokegen/strokegen_sync.hh  |  49 +++++
 .../strokegen/strokegen_sync_handles.hh       | 171 ++++++++++++++++++
 7 files changed, 276 insertions(+), 2 deletions(-)
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_defines.hh
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_shader_shared.hh
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_sync.cc
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_sync.hh
 create mode 100644 source/blender/draw/engines/strokegen/strokegen_sync_handles.hh

diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
index 76bdd97ae20..33243161d91 100644
--- a/source/blender/draw/CMakeLists.txt
+++ b/source/blender/draw/CMakeLists.txt
@@ -211,6 +211,9 @@ set(SRC
   engines/strokegen/strokegen_engine.cc
   engines/strokegen/strokegen_shader.cc
   engines/strokegen/strokegen_instance.cc
+  engines/strokegen/strokegen_sync.cc
+
+
 
 
 
@@ -305,6 +308,8 @@ set(SRC
   engines/strokegen/strokegen_engine.h
   engines/strokegen/strokegen_shader.hh
   engines/strokegen/strokegen_instance.hh
+  engines/strokegen/strokegen_sync_handles.hh
+  engines/strokegen/strokegen_sync.hh
 )
 
 set(LIB
diff --git a/source/blender/draw/engines/strokegen/strokegen_defines.hh b/source/blender/draw/engines/strokegen/strokegen_defines.hh
new file mode 100644
index 00000000000..a1900395cc8
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_defines.hh
@@ -0,0 +1,10 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+ * Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup eevee
+ *
+ * List of defines that are shared with the GPUShaderCreateInfos. We do this to avoid
+ * dragging larger headers into the createInfo pipeline which would cause problems.
+ */
diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.hh b/source/blender/draw/engines/strokegen/strokegen_instance.hh
index ac1332c5838..6567f88cfaa 100644
--- a/source/blender/draw/engines/strokegen/strokegen_instance.hh
+++ b/source/blender/draw/engines/strokegen/strokegen_instance.hh
@@ -22,6 +22,7 @@
 #include "draw_manager.hh"
 #include "draw_pass.hh"
 #include "strokegen_shader.hh"
+#include "strokegen_sync.hh"
 
 
 namespace blender::strokegen
@@ -35,7 +36,7 @@ namespace blender::strokegen
   public:
     /** Shading Modules */
     ShaderModule shaders; // singleton class for handling GPUShader(s)
-
+    SyncModule sync;
 
     /** Input data. */
     Depsgraph *depsgraph;
@@ -62,7 +63,9 @@ namespace blender::strokegen
 
 
   public:
-    Instance() : shaders(*ShaderModule::module_get())
+    Instance() :
+    shaders(*ShaderModule::module_get()),
+    sync(*this)
     {
     };
 
diff --git a/source/blender/draw/engines/strokegen/strokegen_shader_shared.hh b/source/blender/draw/engines/strokegen/strokegen_shader_shared.hh
new file mode 100644
index 00000000000..ca4e6ad46d7
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_shader_shared.hh
@@ -0,0 +1,7 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+/**
+ * Shared structures, enums & defines between C++ and GLSL.
+ * Can also include some math functions but they need to be simple enough to be valid in both
+ * language.
+ */
diff --git a/source/blender/draw/engines/strokegen/strokegen_sync.cc b/source/blender/draw/engines/strokegen/strokegen_sync.cc
new file mode 100644
index 00000000000..2eda953508b
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_sync.cc
@@ -0,0 +1,29 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup eevee
+ *
+ * Converts the different renderable object types to drawcalls.
+ */
+
+#include "strokegen_engine.h"
+
+#include "BKE_gpencil.h"
+#include "BKE_object.h"
+#include "DEG_depsgraph_query.h"
+#include "DNA_curves_types.h"
+#include "DNA_gpencil_types.h"
+#include "DNA_modifier_types.h"
+#include "DNA_particle_types.h"
+
+#include "strokegen_instance.hh"
+#include "strokegen_sync.hh"
+
+namespace blender::strokegen
+{
+
+
+
+}
diff --git a/source/blender/draw/engines/strokegen/strokegen_sync.hh b/source/blender/draw/engines/strokegen/strokegen_sync.hh
new file mode 100644
index 00000000000..ff979e63d6e
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_sync.hh
@@ -0,0 +1,49 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup eevee
+ *
+ * Module for synchronization between draw engine and outside
+ */
+
+#pragma once
+
+#include "BKE_duplilist.h"
+#include "BLI_ghash.h"
+#include "BLI_map.hh"
+#include "DNA_object_types.h"
+#include "DRW_render.h"
+#include "GPU_material.h"
+
+#include "strokegen_shader_shared.hh"
+#include "strokegen_sync_handles.hh"
+
+namespace blender::strokegen
+{
+
+  class Instance;
+
+  class SyncModule
+  {
+  private:
+    Instance &inst_;
+
+  public:
+    SyncModule(Instance &inst) : inst_(inst) {};
+    ~SyncModule(){};
+
+    ObjectHandle &sync_object(Object *ob) {};
+    WorldHandle &sync_world(::World *world) {};
+    SceneHandle &sync_scene(::Scene *scene) {};
+
+    void sync_mesh(Object *ob,
+                   ObjectHandle &ob_handle,
+                   draw::ResourceHandle res_handle,
+                   const draw::ObjectRef &ob_ref) {};
+  };
+
+}
+
+
diff --git a/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh b/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh
new file mode 100644
index 00000000000..2e0354a856d
--- /dev/null
+++ b/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh
@@ -0,0 +1,171 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup eevee
+ *
+ * Structures to identify unique data blocks.
+ * The keys are unique so we are able to match ids across frame updates.
+ */
+
+#pragma once
+
+
+// Copied from eevee_sync.hh
+
+namespace blender::strokegen
+{
+  /* -------------------------------------------------------------------- */
+  /** \name ObjectKey
+   *
+   * Unique key to identify each object in the hash-map.
+   * Note that we get a unique key for each object component.
+   * \{ */
+
+  struct ObjectKey
+  {
+    /** Hash value of the key. */
+    uint64_t hash_value;
+    /** Original Object or source object for duplis. */
+    Object* ob;
+    /** Original Parent object for duplis. */
+    Object* parent;
+    /** Dupli objects recursive unique identifier */
+    int id[MAX_DUPLI_RECUR];
+    /** If object uses particle system hair. */
+    bool use_particle_hair;
+#ifdef DEBUG
+    char name[64];
+#endif
+    ObjectKey() : ob(nullptr), parent(nullptr)
+    {
+    };
+
+    ObjectKey(Object* ob_, Object* parent_, int id_[MAX_DUPLI_RECUR], bool use_particle_hair_)
+      : ob(ob_), parent(parent_), use_particle_hair(use_particle_hair_)
+    {
+      if (id_)
+      {
+        memcpy(id, id_, sizeof(id));
+      }
+      else
+      {
+        memset(id, 0, sizeof(id));
+      }
+      /* Compute hash on creation so we avoid the cost of it for every sync. */
+      hash_value = BLI_ghashutil_ptrhash(ob);
+      hash_value = BLI_ghashutil_combine_hash(hash_value, BLI_ghashutil_ptrhash(parent));
+      for (int i = 0; i < MAX_DUPLI_RECUR; i++)
+      {
+        if (id[i] != 0)
+        {
+          hash_value = BLI_ghashutil_combine_hash(hash_value, BLI_ghashutil_inthash(id[i]));
+        }
+        else
+        {
+          break;
+        }
+      }
+#ifdef DEBUG
+      STRNCPY(name, ob->id.name);
+#endif
+    }
+
+    ObjectKey(Object* ob, DupliObject* dupli, Object* parent)
+      : ObjectKey(ob, parent, dupli ? dupli->persistent_id : nullptr, false)
+    {
+    };
+
+    ObjectKey(Object* ob)
+      : ObjectKey(ob, DRW_object_get_dupli(ob), DRW_object_get_dupli_parent(ob))
+    {
+    };
+
+    uint64_t hash() const
+    {
+      return hash_value;
+    }
+
+    bool operator<(const ObjectKey& k) const
+    {
+      if (ob != k.ob)
+      {
+        return (ob < k.ob);
+      }
+      if (parent != k.parent)
+      {
+        return (parent < k.parent);
+      }
+      if (use_particle_hair != k.use_particle_hair)
+      {
+        return (use_particle_hair < k.use_particle_hair);
+      }
+      return memcmp(id, k.id, sizeof(id)) < 0;
+    }
+
+    bool operator==(const ObjectKey& k) const
+    {
+      if (ob != k.ob)
+      {
+        return false;
+      }
+      if (parent != k.parent)
+      {
+        return false;
+      }
+      if (use_particle_hair != k.use_particle_hair)
+      {
+        return false;
+      }
+      return memcmp(id, k.id, sizeof(id)) == 0;
+    }
+  };
+
+  /** \} */
+
+  /* -------------------------------------------------------------------- */
+  /** \name Sync Module
+   *
+   * \{ */
+
+  struct ObjectHandle : public DrawData
+  {
+    ObjectKey object_key;
+
+    void reset_recalc_flag()
+    {
+      if (recalc != 0)
+      {
+        recalc = 0;
+      }
+    }
+  };
+
+  struct WorldHandle : public DrawData
+  {
+    void reset_recalc_flag()
+    {
+      if (recalc != 0)
+      {
+        recalc = 0;
+      }
+    }
+  };
+
+  struct SceneHandle : public DrawData
+  {
+    void reset_recalc_flag()
+    {
+      if (recalc != 0)
+      {
+        recalc = 0;
+      }
+    }
+  };
+
+
+
+}
+
+/** \} */
-- 
2.38.1.windows.1


From b9653cd9fc75bc4d5eac95fdb1a4f9b142616c14 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sun, 4 Dec 2022 21:08:13 +0800
Subject: [PATCH 04/11] Change engine name from strokegen to bnpr

---
 source/blender/draw/CMakeLists.txt            |  25 ++-
 .../bnpr_engine.cc}                           | 168 +++++++++---------
 .../strokegen_engine.h => bnpr/bnpr_engine.h} |   4 +-
 .../bnpr_instance.cc}                         |   6 +-
 .../bnpr_instance.hh}                         |   8 +-
 .../bnpr_shader.cc}                           |  12 +-
 .../bnpr_shader.hh}                           |   6 +-
 source/blender/draw/engines/bnpr/bnpr_sync.cc |  45 +++++
 .../strokegen_sync.hh => bnpr/bnpr_sync.hh}   |   6 +-
 .../bnpr_sync_handles.hh}                     |   2 +-
 .../shaders/infos/strokegen_depth_info.hh     |   0
 .../shaders/strokegen_depth_curves_vert.glsl  |   0
 .../shaders/strokegen_depth_frag.glsl         |   0
 .../strokegen_depth_pointcloud_vert.glsl      |   0
 .../shaders/strokegen_depth_vert.glsl         |   0
 .../strokgen_conservative_depth_geom.glsl     |   0
 .../{strokegen => bnpr}/strokegen_defines.hh  |   0
 .../strokegen_shader_shared.hh                |   0
 .../draw/engines/strokegen/strokegen_sync.cc  |  29 ---
 source/blender/draw/intern/draw_manager.c     |   6 +-
 20 files changed, 170 insertions(+), 147 deletions(-)
 rename source/blender/draw/engines/{strokegen/strokegen_engine.cc => bnpr/bnpr_engine.cc} (68%)
 rename source/blender/draw/engines/{strokegen/strokegen_engine.h => bnpr/bnpr_engine.h} (87%)
 rename source/blender/draw/engines/{strokegen/strokegen_instance.cc => bnpr/bnpr_instance.cc} (97%)
 rename source/blender/draw/engines/{strokegen/strokegen_instance.hh => bnpr/bnpr_instance.hh} (94%)
 rename source/blender/draw/engines/{strokegen/strokegen_shader.cc => bnpr/bnpr_shader.cc} (87%)
 rename source/blender/draw/engines/{strokegen/strokegen_shader.hh => bnpr/bnpr_shader.hh} (92%)
 create mode 100644 source/blender/draw/engines/bnpr/bnpr_sync.cc
 rename source/blender/draw/engines/{strokegen/strokegen_sync.hh => bnpr/bnpr_sync.hh} (89%)
 rename source/blender/draw/engines/{strokegen/strokegen_sync_handles.hh => bnpr/bnpr_sync_handles.hh} (99%)
 rename source/blender/draw/engines/{strokegen => bnpr}/shaders/infos/strokegen_depth_info.hh (100%)
 rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokegen_depth_curves_vert.glsl (100%)
 rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokegen_depth_frag.glsl (100%)
 rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokegen_depth_pointcloud_vert.glsl (100%)
 rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokegen_depth_vert.glsl (100%)
 rename source/blender/draw/engines/{strokegen => bnpr}/shaders/strokgen_conservative_depth_geom.glsl (100%)
 rename source/blender/draw/engines/{strokegen => bnpr}/strokegen_defines.hh (100%)
 rename source/blender/draw/engines/{strokegen => bnpr}/strokegen_shader_shared.hh (100%)
 delete mode 100644 source/blender/draw/engines/strokegen/strokegen_sync.cc

diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
index 33243161d91..90579052df5 100644
--- a/source/blender/draw/CMakeLists.txt
+++ b/source/blender/draw/CMakeLists.txt
@@ -208,10 +208,10 @@ set(SRC
   engines/overlay/overlay_viewer_attribute.cc
   engines/overlay/overlay_volume.cc
   engines/overlay/overlay_wireframe.cc
-  engines/strokegen/strokegen_engine.cc
-  engines/strokegen/strokegen_shader.cc
-  engines/strokegen/strokegen_instance.cc
-  engines/strokegen/strokegen_sync.cc
+  engines/bnpr/bnpr_engine.cc
+  engines/bnpr/bnpr_shader.cc
+  engines/bnpr/bnpr_instance.cc
+  engines/bnpr/bnpr_sync.cc
 
 
 
@@ -305,11 +305,11 @@ set(SRC
   engines/select/select_private.h
   engines/overlay/overlay_engine.h
   engines/overlay/overlay_private.hh
-  engines/strokegen/strokegen_engine.h
-  engines/strokegen/strokegen_shader.hh
-  engines/strokegen/strokegen_instance.hh
-  engines/strokegen/strokegen_sync_handles.hh
-  engines/strokegen/strokegen_sync.hh
+  engines/bnpr/bnpr_engine.h
+  engines/bnpr/bnpr_shader.hh
+  engines/bnpr/bnpr_instance.hh
+  engines/bnpr/bnpr_sync_handles.hh
+  engines/bnpr/bnpr_sync.hh
 )
 
 set(LIB
@@ -699,6 +699,13 @@ set(GLSL_SRC
   engines/image/shaders/image_engine_color_vert.glsl
   engines/image/shaders/image_engine_depth_frag.glsl
   engines/image/shaders/image_engine_depth_vert.glsl
+
+
+
+
+
+
+
 )
 
 set(GLSL_C)
diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.cc b/source/blender/draw/engines/bnpr/bnpr_engine.cc
similarity index 68%
rename from source/blender/draw/engines/strokegen/strokegen_engine.cc
rename to source/blender/draw/engines/bnpr/bnpr_engine.cc
index 56b3b170660..0e123f6e50c 100644
--- a/source/blender/draw/engines/strokegen/strokegen_engine.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_engine.cc
@@ -17,72 +17,72 @@
 
 #include "GPU_shader.h"
 
-#include "strokegen_engine.h"
+#include "bnpr_engine.h"
 
-#include "strokegen_instance.hh"
-#include "strokegen_shader.hh"
+#include "bnpr_instance.hh"
+#include "bnpr_shader.hh"
 
 
 using namespace blender;
 
 
 
-#define STROKEGEN_ENGINE "BLENDER_STROKEGEN"
+#define bnpr_ENGINE "BLENDER_bnpr"
 
 /* *********** LISTS *********** */
 
 /* GPUViewport.storage
  * Is freed every time the viewport engine changes. */
-typedef struct STROKEGEN_StorageList {
-  struct STROKEGEN_PrivateData *g_data;
-} STROKEGEN_StorageList;
+typedef struct bnpr_StorageList {
+  struct bnpr_PrivateData *g_data;
+} bnpr_StorageList;
 
-typedef struct STROKEGEN_PassList {
+typedef struct bnpr_PassList {
   struct DRWPass *depth_pass[2];
   struct DRWPass *depth_pass_pointcloud[2];
   struct DRWPass *depth_pass_cull[2];
-} STROKEGEN_PassList;
+} bnpr_PassList;
 
 // Per-engine data
 // Sent by draw manager to the draw-engine.
-typedef struct STROKEGEN_Data {
+typedef struct bnpr_Data {
   void *engine_type;
   DRWViewportEmptyList *fbl;
   DRWViewportEmptyList *txl;
-  STROKEGEN_PassList *psl;
-  STROKEGEN_StorageList *stl;
+  bnpr_PassList *psl;
+  bnpr_StorageList *stl;
 
-  strokegen::Instance *instance;
+  bnpr::Instance *instance;
   char info[GPU_INFO_SIZE];
 
-} STROKEGEN_Data;
+} bnpr_Data;
 
 /* *********** STATIC *********** */
 
-typedef struct STROKEGEN_PrivateData {
+typedef struct bnpr_PrivateData {
   DRWShadingGroup *depth_shgrp[2];
   DRWShadingGroup *depth_shgrp_cull[2];
   DRWShadingGroup *depth_hair_shgrp[2];
   DRWShadingGroup *depth_curves_shgrp[2];
   DRWShadingGroup *depth_pointcloud_shgrp[2];
   bool use_material_slot_selection;
-} STROKEGEN_PrivateData; /* Transient data */
+} bnpr_PrivateData; /* Transient data */
 
 
 
-static bool check_strokegen_support()
+static bool check_bnpr_support()
 {
   return GPU_shader_storage_buffer_objects_support();
 }
 
 
-static void strokegen_engine_init(void *vedata)
+static void bnpr_engine_init(void *vedata)
 {
-  if (!check_strokegen_support()) { return; }
+  if (!check_bnpr_support()) { return; }
 
-  STROKEGEN_Data *ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
+  bnpr_Data *ved = reinterpret_cast<bnpr_Data *>(vedata);
   if (ved->instance == nullptr) {
-    ved->instance = new strokegen::Instance();
+    ved->instance = new bnpr::Instance();
   }
 
   draw::Manager *drw_mgr = DRW_manager_get();
@@ -109,9 +109,9 @@ static void strokegen_engine_init(void *vedata)
 
 
 
-static void strokegen_draw_scene_legacy(void *vedata)
+static void bnpr_draw_scene_legacy(void *vedata)
 {
-  STROKEGEN_PassList *psl = ((STROKEGEN_Data *)vedata)->psl;
+  bnpr_PassList *psl = ((bnpr_Data *)vedata)->psl;
 
   DRW_draw_pass(psl->depth_pass[0]);
   DRW_draw_pass(psl->depth_pass_pointcloud[0]);
@@ -121,11 +121,11 @@ static void strokegen_draw_scene_legacy(void *vedata)
   DRW_draw_pass(psl->depth_pass_cull[1]);
 }
 
-static void strokegen_draw_scene(void *vedata)
+static void bnpr_draw_scene(void *vedata)
 {
-  STROKEGEN_Data *ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
-  if (!check_strokegen_support()) {
-    STRNCPY(ved->info, "Error: No shader storage buffer support, required by StrokeGen.");
+  bnpr_Data *ved = reinterpret_cast<bnpr_Data *>(vedata);
+  if (!check_bnpr_support()) {
+    STRNCPY(ved->info, "Error: No shader storage buffer support, required by bnpr.");
     return;
   }
 
@@ -144,7 +144,7 @@ static void strokegen_draw_scene(void *vedata)
 
 
 
-  strokegen_draw_scene_legacy(vedata);
+  bnpr_draw_scene_legacy(vedata);
 
 
   /* Reset view for other following engines. */
@@ -154,17 +154,17 @@ static void strokegen_draw_scene(void *vedata)
 
 
 
-static void strokegen_cache_init_legacy(void *vedata)
+static void bnpr_cache_init_legacy(void *vedata)
 {
-  STROKEGEN_PassList *psl = static_cast<STROKEGEN_Data*>(vedata)->psl;
-  STROKEGEN_StorageList *stl = static_cast<STROKEGEN_Data*>(vedata)->stl;
+  bnpr_PassList *psl = static_cast<bnpr_Data*>(vedata)->psl;
+  bnpr_StorageList *stl = static_cast<bnpr_Data*>(vedata)->stl;
   DRWShadingGroup *grp;
 
   const DRWContextState *draw_ctx = DRW_context_state_get();
 
   if (!stl->g_data) {
     /* Alloc transient pointers */
-    stl->g_data = (STROKEGEN_PrivateData* )MEM_callocN(sizeof(*stl->g_data), __func__);
+    stl->g_data = (bnpr_PrivateData* )MEM_callocN(sizeof(*stl->g_data), __func__);
   }
 
   stl->g_data->use_material_slot_selection = DRW_state_is_material_select();
@@ -179,50 +179,50 @@ static void strokegen_cache_init_legacy(void *vedata)
     );
     DRWState state = DRW_STATE_WRITE_DEPTH | DRW_STATE_DEPTH_LESS_EQUAL;
 
-    blender::strokegen::ShaderModule* shaderModule =
-      blender::strokegen::ShaderModule::module_get();
+    blender::bnpr::ShaderModule* shaderModule =
+      blender::bnpr::ShaderModule::module_get();
 
     GPUShader *sh = DRW_state_is_select() ?
-                        shaderModule->static_shader_get(blender::strokegen::DEPTH_CONSERVATIVE) :
-                        shaderModule->static_shader_get(blender::strokegen::DEPTH);
+                        shaderModule->static_shader_get(blender::bnpr::DEPTH_CONSERVATIVE) :
+                        shaderModule->static_shader_get(blender::bnpr::DEPTH);
 
     DRW_PASS_CREATE(psl->depth_pass[i], state | clip_state | infront_state);
     stl->g_data->depth_shgrp[i] = grp = DRW_shgroup_create(sh, psl->depth_pass[i]);
     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
 
     sh = DRW_state_is_select() ?
-        shaderModule->static_shader_get(blender::strokegen::POINTCLOUD_DEPTH_CONSERVATIVE) :
-        shaderModule->static_shader_get(blender::strokegen::POINTCLOUD_DEPTH);
+        shaderModule->static_shader_get(blender::bnpr::POINTCLOUD_DEPTH_CONSERVATIVE) :
+        shaderModule->static_shader_get(blender::bnpr::POINTCLOUD_DEPTH);
     DRW_PASS_CREATE(psl->depth_pass_pointcloud[i], state | clip_state | infront_state);
     stl->g_data->depth_pointcloud_shgrp[i] = grp = DRW_shgroup_create(
         sh, psl->depth_pass_pointcloud[i]);
     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
 
     stl->g_data->depth_hair_shgrp[i] = grp = DRW_shgroup_create(
-        shaderModule->static_shader_get(blender::strokegen::DEPTH), psl->depth_pass[i]);
+        shaderModule->static_shader_get(blender::bnpr::DEPTH), psl->depth_pass[i]);
     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
 
     stl->g_data->depth_curves_shgrp[i] = grp = DRW_shgroup_create(
-        shaderModule->static_shader_get(blender::strokegen::CURVES_DEPTH), psl->depth_pass[i]);
+        shaderModule->static_shader_get(blender::bnpr::CURVES_DEPTH), psl->depth_pass[i]);
     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
 
-    sh = DRW_state_is_select() ? shaderModule->static_shader_get(blender::strokegen::DEPTH_CONSERVATIVE) :
-                                 shaderModule->static_shader_get(blender::strokegen::DEPTH);
+    sh = DRW_state_is_select() ? shaderModule->static_shader_get(blender::bnpr::DEPTH_CONSERVATIVE) :
+                                 shaderModule->static_shader_get(blender::bnpr::DEPTH);
     state |= DRW_STATE_CULL_BACK;
     DRW_PASS_CREATE(psl->depth_pass_cull[i], state | clip_state | infront_state);
     stl->g_data->depth_shgrp_cull[i] = grp = DRW_shgroup_create(sh, psl->depth_pass_cull[i]);
     DRW_shgroup_uniform_block(grp, "globalsBlock", G_draw.block_ubo);
   }
 }
-static void strokegen_cache_init(void *vedata)
+static void bnpr_cache_init(void *vedata)
 {
-  if (!check_strokegen_support()) return;
+  if (!check_bnpr_support()) return;
 
   draw::Manager* drwmgr = DRW_manager_get();
-  reinterpret_cast<STROKEGEN_Data *>(vedata)->instance->begin_sync(*drwmgr);
+  reinterpret_cast<bnpr_Data *>(vedata)->instance->begin_sync(*drwmgr);
 
 
-  strokegen_cache_init_legacy(vedata);
+  bnpr_cache_init_legacy(vedata);
 }
 
 
@@ -235,7 +235,7 @@ static void strokegen_cache_init(void *vedata)
 
 /* TODO(fclem): DRW_cache_object_surface_material_get needs a refactor to allow passing NULL
  * instead of gpumat_array. Avoiding all this boilerplate code. */
-static struct GPUBatch **strokegen_object_surface_material_get(Object *ob)
+static struct GPUBatch **bnpr_object_surface_material_get(Object *ob)
 {
   const int materials_len = DRW_cache_object_material_count_get(ob);
   struct GPUMaterial **gpumat_array =
@@ -245,14 +245,14 @@ static struct GPUBatch **strokegen_object_surface_material_get(Object *ob)
   return DRW_cache_object_surface_material_get(ob, gpumat_array, materials_len);
 }
 
-static void strokegen_cache_populate_particles(void *vedata, Object *ob)
+static void bnpr_cache_populate_particles(void *vedata, Object *ob)
 {
   // do nothing here.
 }
 
-static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
+static void bnpr_cache_populate_legacy(void *vedata, Object *ob)
 {
-  STROKEGEN_StorageList *stl = ((STROKEGEN_Data *)vedata)->stl;
+  bnpr_StorageList *stl = ((bnpr_Data *)vedata)->stl;
 
   /* TODO(fclem): fix selection of smoke domains. */
 
@@ -262,7 +262,7 @@ static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
 
   const DRWContextState *draw_ctx = DRW_context_state_get();
   if (ob != draw_ctx->object_edit) {
-    strokegen_cache_populate_particles(vedata, ob);
+    bnpr_cache_populate_particles(vedata, ob);
   }
 
   const bool do_in_front = (ob->dtx & OB_DRAW_IN_FRONT) != 0;
@@ -308,7 +308,7 @@ static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
   }
   else {
     if (stl->g_data->use_material_slot_selection && BKE_object_supports_material_slots(ob)) {
-      struct GPUBatch **geoms = strokegen_object_surface_material_get(ob);
+      struct GPUBatch **geoms = bnpr_object_surface_material_get(ob);
       if (geoms) {
         const int materials_len = DRW_cache_object_material_count_get(ob);
         for (int i = 0; i < materials_len; i++) {
@@ -329,11 +329,11 @@ static void strokegen_cache_populate_legacy(void *vedata, Object *ob)
     }
   }
 }
-static void strokegen_cache_populate(void *vedata, Object *object)
+static void bnpr_cache_populate(void *vedata, Object *object)
 {
-  if (!check_strokegen_support()) return;
+  if (!check_bnpr_support()) return;
 
-  STROKEGEN_Data* ved = reinterpret_cast<STROKEGEN_Data *>(vedata);
+  bnpr_Data* ved = reinterpret_cast<bnpr_Data *>(vedata);
 
   draw::Manager* drw_mgr = DRW_manager_get();
   draw::ObjectRef ref {
@@ -346,43 +346,43 @@ static void strokegen_cache_populate(void *vedata, Object *object)
 
 
 
-  strokegen_cache_populate_legacy(vedata, object);
+  bnpr_cache_populate_legacy(vedata, object);
 }
 
 
-static void strokegen_cache_finish_legacy(void *vedata)
+static void bnpr_cache_finish_legacy(void *vedata)
 {
-  STROKEGEN_StorageList *stl = ((STROKEGEN_Data *)vedata)->stl;
+  bnpr_StorageList *stl = ((bnpr_Data *)vedata)->stl;
 
   UNUSED_VARS(stl);
 }
-static void strokegen_cache_finish(void *vedata)
+static void bnpr_cache_finish(void *vedata)
 {
-  if (!check_strokegen_support()) return;
+  if (!check_bnpr_support()) return;
 
-  STROKEGEN_Data* ved = reinterpret_cast<STROKEGEN_Data*>(vedata);
+  bnpr_Data* ved = reinterpret_cast<bnpr_Data*>(vedata);
   draw::Manager* drw_mgr = DRW_manager_get();
 
   ved->instance->end_sync(*drw_mgr);
 
 
 
-  strokegen_cache_finish_legacy(vedata);
+  bnpr_cache_finish_legacy(vedata);
 }
 
-static void strokegen_instance_free(void *instance) {
+static void bnpr_instance_free(void *instance) {
   if (!GPU_shader_storage_buffer_objects_support()) {
     return;
   }
-  delete reinterpret_cast<strokegen::Instance *>(instance);
+  delete reinterpret_cast<bnpr::Instance *>(instance);
 }
 
-static void strokegen_engine_free(void)
+static void bnpr_engine_free(void)
 {
-  strokegen::ShaderModule::module_free();
+  bnpr::ShaderModule::module_free();
 }
 
-static void strokegen_render_to_image(void *vedata, struct RenderEngine *engine,
+static void bnpr_render_to_image(void *vedata, struct RenderEngine *engine,
                                     struct RenderLayer *layer,
                                     const struct rcti *UNUSED(rect)) {
   UNUSED_VARS(vedata, engine, layer);
@@ -393,31 +393,31 @@ static void strokegen_render_to_image(void *vedata, struct RenderEngine *engine,
 
 
 
-static const DrawEngineDataSize strokegen_data_size = DRW_VIEWPORT_DATA_SIZE(STROKEGEN_Data);
+static const DrawEngineDataSize bnpr_data_size = DRW_VIEWPORT_DATA_SIZE(bnpr_Data);
 
-DrawEngineType draw_engine_strokegen_type = {
+DrawEngineType draw_engine_bnpr_type = {
     NULL,
     NULL,
-    N_("StrokeGen"),
-    &strokegen_data_size,
-    strokegen_engine_init,
-    &strokegen_engine_free,
-    &strokegen_instance_free,
-    &strokegen_cache_init,
-    &strokegen_cache_populate,
-    &strokegen_cache_finish,
-    &strokegen_draw_scene,
+    N_("bnpr"),
+    &bnpr_data_size,
+    bnpr_engine_init,
+    &bnpr_engine_free,
+    &bnpr_instance_free,
+    &bnpr_cache_init,
+    &bnpr_cache_populate,
+    &bnpr_cache_finish,
+    &bnpr_draw_scene,
     NULL,
     NULL,
-    strokegen_render_to_image,
+    bnpr_render_to_image,
     NULL,
 };
 
-RenderEngineType DRW_engine_viewport_strokegen_type = {
+RenderEngineType DRW_engine_viewport_bnpr_type = {
   nullptr,
   nullptr,
-  "STROKEGEN_VIEW",
-  N_("strokegen"),
+  "bnpr_VIEW",
+  N_("bnpr"),
   RE_INTERNAL | RE_USE_PREVIEW | RE_USE_STEREO_VIEWPORT | RE_USE_GPU_CONTEXT,
   nullptr,
   &DRW_render_to_image,
@@ -428,8 +428,8 @@ RenderEngineType DRW_engine_viewport_strokegen_type = {
   nullptr,
   nullptr,
   nullptr, // TODO: impl this
-  &draw_engine_strokegen_type,
+  &draw_engine_bnpr_type,
   {nullptr, nullptr, nullptr},
 };
 
-#undef STROKEGEN_ENGINE
+#undef bnpr_ENGINE
diff --git a/source/blender/draw/engines/strokegen/strokegen_engine.h b/source/blender/draw/engines/bnpr/bnpr_engine.h
similarity index 87%
rename from source/blender/draw/engines/strokegen/strokegen_engine.h
rename to source/blender/draw/engines/bnpr/bnpr_engine.h
index 0df3623e738..842c7d664a5 100644
--- a/source/blender/draw/engines/strokegen/strokegen_engine.h
+++ b/source/blender/draw/engines/bnpr/bnpr_engine.h
@@ -14,8 +14,8 @@
 extern "C" { // to satisfy .cc files
 #endif
 
-extern DrawEngineType draw_engine_strokegen_type;
-extern RenderEngineType DRW_engine_viewport_strokegen_type;
+extern DrawEngineType draw_engine_bnpr_type;
+extern RenderEngineType DRW_engine_viewport_bnpr_type;
 
 // Also I spent some time reading the mesh extraction code,
 // feel like I could add one or more new mesh buffers & extractors?
diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.cc b/source/blender/draw/engines/bnpr/bnpr_instance.cc
similarity index 97%
rename from source/blender/draw/engines/strokegen/strokegen_instance.cc
rename to source/blender/draw/engines/bnpr/bnpr_instance.cc
index 74037bf3b76..5139b0c5f49 100644
--- a/source/blender/draw/engines/strokegen/strokegen_instance.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.cc
@@ -3,7 +3,7 @@
  */
 
 /** \file
- * \ingroup strokegen
+ * \ingroup bnpr
  *
  * An instance contains all structures needed to do a complete render.
  */
@@ -19,9 +19,9 @@
 #include "DNA_modifier_types.h"
 #include "RE_pipeline.h"
 
-#include "strokegen_instance.hh"
+#include "bnpr_instance.hh"
 
-namespace blender::strokegen
+namespace blender::bnpr
 {
   /* -------------------------------------------------------------------- */
   /** \name Initialization
diff --git a/source/blender/draw/engines/strokegen/strokegen_instance.hh b/source/blender/draw/engines/bnpr/bnpr_instance.hh
similarity index 94%
rename from source/blender/draw/engines/strokegen/strokegen_instance.hh
rename to source/blender/draw/engines/bnpr/bnpr_instance.hh
index 6567f88cfaa..5f6a7374b89 100644
--- a/source/blender/draw/engines/strokegen/strokegen_instance.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.hh
@@ -3,7 +3,7 @@
  */
 
 /** \file
- * \ingroup strokegen
+ * \ingroup bnpr
  *
  * An renderer instance that contains all data to render a full frame.
 */
@@ -21,11 +21,11 @@
 
 #include "draw_manager.hh"
 #include "draw_pass.hh"
-#include "strokegen_shader.hh"
-#include "strokegen_sync.hh"
+#include "bnpr_shader.hh"
+#include "bnpr_sync.hh"
 
 
-namespace blender::strokegen
+namespace blender::bnpr
 {
   using namespace draw;
 
diff --git a/source/blender/draw/engines/strokegen/strokegen_shader.cc b/source/blender/draw/engines/bnpr/bnpr_shader.cc
similarity index 87%
rename from source/blender/draw/engines/strokegen/strokegen_shader.cc
rename to source/blender/draw/engines/bnpr/bnpr_shader.cc
index efe37087ef0..7bf72caf057 100644
--- a/source/blender/draw/engines/strokegen/strokegen_shader.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_shader.cc
@@ -13,9 +13,9 @@
 
 #include "gpu_shader_create_info.hh"
 
-#include "strokegen_shader.hh"
+#include "bnpr_shader.hh"
 
-namespace blender::strokegen {
+namespace blender::bnpr {
 
 /* -------------------------------------------------------------------- */
 /** \name Module
@@ -53,12 +53,12 @@ ShaderModule::ShaderModule()
   for (auto i : IndexRange(MAX_SHADER_TYPE)) {
     const char *name = static_shader_create_info_name_get(eShaderType(i));
     if (name == nullptr) {
-      std::cerr << "STROKEGEN: Missing case for eShaderType(" << i
+      std::cerr << "bnpr: Missing case for eShaderType(" << i
                 << ") in static_shader_create_info_name_get().";
       BLI_assert(0);
     }
     const GPUShaderCreateInfo *create_info = GPU_shader_create_info_get(name);
-    BLI_assert_msg(create_info != nullptr, "STROKEGEN: Missing create info for static shader.");
+    BLI_assert_msg(create_info != nullptr, "bnpr: Missing create info for static shader.");
   }
 #endif
 }
@@ -106,7 +106,7 @@ GPUShader *ShaderModule::static_shader_get(eShaderType shader_type)
     shaders_[shader_type] = GPU_shader_create_from_info_name(shader_name);
 
     if (shaders_[shader_type] == nullptr) {
-      fprintf(stderr, "STROKEGEN: error: Could not compile static shader \"%s\"\n", shader_name);
+      fprintf(stderr, "bnpr: error: Could not compile static shader \"%s\"\n", shader_name);
     }
     BLI_assert(shaders_[shader_type] != nullptr);
   }
@@ -116,4 +116,4 @@ GPUShader *ShaderModule::static_shader_get(eShaderType shader_type)
 
 /** \} */
 
-}  // namespace blender::strokegen
+}  // namespace blender::bnpr
diff --git a/source/blender/draw/engines/strokegen/strokegen_shader.hh b/source/blender/draw/engines/bnpr/bnpr_shader.hh
similarity index 92%
rename from source/blender/draw/engines/strokegen/strokegen_shader.hh
rename to source/blender/draw/engines/bnpr/bnpr_shader.hh
index 92f8e90a4fe..9b756e213a4 100644
--- a/source/blender/draw/engines/strokegen/strokegen_shader.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader.hh
@@ -3,7 +3,7 @@
  */
 
 /** \file
- * \ingroup strokegen
+ * \ingroup bnpr
  *
  * Shader module that manage shader libraries, deferred compilation,
  * and static shader usage.
@@ -20,7 +20,7 @@
 #include "GPU_shader.h"
 
 
-namespace blender::strokegen {
+namespace blender::bnpr {
 
 /* Keep alphabetical order and clean prefix. */
 enum eShaderType {
@@ -59,4 +59,4 @@ class ShaderModule {
   const char *static_shader_create_info_name_get(eShaderType shader_type);
 };
 
-}  // namespace blender::strokegen
+}  // namespace blender::bnpr
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
new file mode 100644
index 00000000000..5bff2b58f9e
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
@@ -0,0 +1,45 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup eevee
+ *
+ * Converts the different renderable object types to drawcalls.
+ */
+
+#include "bnpr_engine.h"
+
+#include "BKE_gpencil.h"
+#include "BKE_object.h"
+#include "DEG_depsgraph_query.h"
+#include "DNA_curves_types.h"
+#include "DNA_gpencil_types.h"
+#include "DNA_modifier_types.h"
+#include "DNA_particle_types.h"
+
+#include "bnpr_instance.hh"
+#include "bnpr_sync.hh"
+
+namespace blender::bnpr
+{
+
+  /* -------------------------------------------------------------------- */
+  /** \name Draw Data
+   *
+   * \{ */
+
+  static void draw_data_init_cb(struct DrawData *dd)
+  {
+    /* Object has just been created or was never evaluated by the engine. */
+    dd->recalc = ID_RECALC_ALL; /* Tag given ID for an update in all the dependency graphs. */
+  }
+
+  // ObjectHandle& SyncModule::sync_object(Object* ob)
+  // {
+  //   DrawEngineType *owner = (DrawEngineType *)&DRW_engine_viewport_bnpr_type;
+  //   return ObjectHandle();
+  // }
+
+
+}
diff --git a/source/blender/draw/engines/strokegen/strokegen_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
similarity index 89%
rename from source/blender/draw/engines/strokegen/strokegen_sync.hh
rename to source/blender/draw/engines/bnpr/bnpr_sync.hh
index ff979e63d6e..fb7f649780b 100644
--- a/source/blender/draw/engines/strokegen/strokegen_sync.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
@@ -17,10 +17,10 @@
 #include "DRW_render.h"
 #include "GPU_material.h"
 
-#include "strokegen_shader_shared.hh"
-#include "strokegen_sync_handles.hh"
+// #include "bnpr_shader_shared.hh"
+#include "bnpr_sync_handles.hh"
 
-namespace blender::strokegen
+namespace blender::bnpr
 {
 
   class Instance;
diff --git a/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh b/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
similarity index 99%
rename from source/blender/draw/engines/strokegen/strokegen_sync_handles.hh
rename to source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
index 2e0354a856d..8fd0fc90070 100644
--- a/source/blender/draw/engines/strokegen/strokegen_sync_handles.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
@@ -14,7 +14,7 @@
 
 // Copied from eevee_sync.hh
 
-namespace blender::strokegen
+namespace blender::bnpr
 {
   /* -------------------------------------------------------------------- */
   /** \name ObjectKey
diff --git a/source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh
similarity index 100%
rename from source/blender/draw/engines/strokegen/shaders/infos/strokegen_depth_info.hh
rename to source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl b/source/blender/draw/engines/bnpr/shaders/strokegen_depth_curves_vert.glsl
similarity index 100%
rename from source/blender/draw/engines/strokegen/shaders/strokegen_depth_curves_vert.glsl
rename to source/blender/draw/engines/bnpr/shaders/strokegen_depth_curves_vert.glsl
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl b/source/blender/draw/engines/bnpr/shaders/strokegen_depth_frag.glsl
similarity index 100%
rename from source/blender/draw/engines/strokegen/shaders/strokegen_depth_frag.glsl
rename to source/blender/draw/engines/bnpr/shaders/strokegen_depth_frag.glsl
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl b/source/blender/draw/engines/bnpr/shaders/strokegen_depth_pointcloud_vert.glsl
similarity index 100%
rename from source/blender/draw/engines/strokegen/shaders/strokegen_depth_pointcloud_vert.glsl
rename to source/blender/draw/engines/bnpr/shaders/strokegen_depth_pointcloud_vert.glsl
diff --git a/source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl b/source/blender/draw/engines/bnpr/shaders/strokegen_depth_vert.glsl
similarity index 100%
rename from source/blender/draw/engines/strokegen/shaders/strokegen_depth_vert.glsl
rename to source/blender/draw/engines/bnpr/shaders/strokegen_depth_vert.glsl
diff --git a/source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl b/source/blender/draw/engines/bnpr/shaders/strokgen_conservative_depth_geom.glsl
similarity index 100%
rename from source/blender/draw/engines/strokegen/shaders/strokgen_conservative_depth_geom.glsl
rename to source/blender/draw/engines/bnpr/shaders/strokgen_conservative_depth_geom.glsl
diff --git a/source/blender/draw/engines/strokegen/strokegen_defines.hh b/source/blender/draw/engines/bnpr/strokegen_defines.hh
similarity index 100%
rename from source/blender/draw/engines/strokegen/strokegen_defines.hh
rename to source/blender/draw/engines/bnpr/strokegen_defines.hh
diff --git a/source/blender/draw/engines/strokegen/strokegen_shader_shared.hh b/source/blender/draw/engines/bnpr/strokegen_shader_shared.hh
similarity index 100%
rename from source/blender/draw/engines/strokegen/strokegen_shader_shared.hh
rename to source/blender/draw/engines/bnpr/strokegen_shader_shared.hh
diff --git a/source/blender/draw/engines/strokegen/strokegen_sync.cc b/source/blender/draw/engines/strokegen/strokegen_sync.cc
deleted file mode 100644
index 2eda953508b..00000000000
--- a/source/blender/draw/engines/strokegen/strokegen_sync.cc
+++ /dev/null
@@ -1,29 +0,0 @@
-Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
-* Copyright 2021 Blender Foundation.
- */
-
-/** \file
- * \ingroup eevee
- *
- * Converts the different renderable object types to drawcalls.
- */
-
-#include "strokegen_engine.h"
-
-#include "BKE_gpencil.h"
-#include "BKE_object.h"
-#include "DEG_depsgraph_query.h"
-#include "DNA_curves_types.h"
-#include "DNA_gpencil_types.h"
-#include "DNA_modifier_types.h"
-#include "DNA_particle_types.h"
-
-#include "strokegen_instance.hh"
-#include "strokegen_sync.hh"
-
-namespace blender::strokegen
-{
-
-
-
-}
diff --git a/source/blender/draw/intern/draw_manager.c b/source/blender/draw/intern/draw_manager.c
index d10488abc22..00a08b38a55 100644
--- a/source/blender/draw/intern/draw_manager.c
+++ b/source/blender/draw/intern/draw_manager.c
@@ -96,7 +96,7 @@
 #include "engines/overlay/overlay_engine.h"
 #include "engines/select/select_engine.h"
 #include "engines/workbench/workbench_engine.h"
-#include "engines/strokegen/strokegen_engine.h"
+#include "engines/bnpr/bnpr_engine.h"
 
 #include "GPU_context.h"
 
@@ -3001,7 +3001,7 @@ void DRW_engines_register(void)
 {
   RE_engines_register(&DRW_engine_viewport_eevee_type);
   RE_engines_register(&DRW_engine_viewport_workbench_type);
-  RE_engines_register(&DRW_engine_viewport_strokegen_type);
+  RE_engines_register(&DRW_engine_viewport_bnpr_type);
 
   DRW_engine_register(&draw_engine_gpencil_type);
 
@@ -3016,7 +3016,7 @@ void DRW_engines_register(void)
   DRW_engine_register(&draw_engine_image_type);
   DRW_engine_register(DRW_engine_viewport_external_type.draw_engine);
 
-  DRW_engine_register(&draw_engine_strokegen_type);
+  DRW_engine_register(&draw_engine_bnpr_type);
 
   /* setup callbacks */
   {
-- 
2.38.1.windows.1


From 4210ae9778c63e64bc47ea195c2aed0731ef500a Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sun, 4 Dec 2022 21:20:09 +0800
Subject: [PATCH 05/11] Added shared shader header files to project

---
 source/blender/draw/CMakeLists.txt                           | 3 +++
 .../engines/bnpr/{strokegen_defines.hh => bnpr_defines.hh}   | 5 ++++-
 .../{strokegen_shader_shared.hh => bnpr_shader_shared.hh}    | 2 ++
 source/blender/draw/engines/bnpr/bnpr_sync.hh                | 2 +-
 4 files changed, 10 insertions(+), 2 deletions(-)
 rename source/blender/draw/engines/bnpr/{strokegen_defines.hh => bnpr_defines.hh} (89%)
 rename source/blender/draw/engines/bnpr/{strokegen_shader_shared.hh => bnpr_shader_shared.hh} (94%)

diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
index 90579052df5..3402caa5f23 100644
--- a/source/blender/draw/CMakeLists.txt
+++ b/source/blender/draw/CMakeLists.txt
@@ -705,6 +705,9 @@ set(GLSL_SRC
 
 
 
+  engines/bnpr/bnpr_defines.hh
+  engines/bnpr/bnpr_shader_shared.hh
+
 
 )
 
diff --git a/source/blender/draw/engines/bnpr/strokegen_defines.hh b/source/blender/draw/engines/bnpr/bnpr_defines.hh
similarity index 89%
rename from source/blender/draw/engines/bnpr/strokegen_defines.hh
rename to source/blender/draw/engines/bnpr/bnpr_defines.hh
index a1900395cc8..dfd63e92d97 100644
--- a/source/blender/draw/engines/bnpr/strokegen_defines.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_defines.hh
@@ -3,8 +3,11 @@
  */
 
 /** \file
- * \ingroup eevee
+ * \ingroup bnpr
  *
  * List of defines that are shared with the GPUShaderCreateInfos. We do this to avoid
  * dragging larger headers into the createInfo pipeline which would cause problems.
  */
+
+
+#pragma once
diff --git a/source/blender/draw/engines/bnpr/strokegen_shader_shared.hh b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
similarity index 94%
rename from source/blender/draw/engines/bnpr/strokegen_shader_shared.hh
rename to source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
index ca4e6ad46d7..9cbb254e58c 100644
--- a/source/blender/draw/engines/bnpr/strokegen_shader_shared.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
@@ -5,3 +5,5 @@
  * Can also include some math functions but they need to be simple enough to be valid in both
  * language.
  */
+
+#pragma once
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
index fb7f649780b..b16e3dda61f 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
@@ -17,7 +17,7 @@
 #include "DRW_render.h"
 #include "GPU_material.h"
 
-// #include "bnpr_shader_shared.hh"
+#include "bnpr_shader_shared.hh"
 #include "bnpr_sync_handles.hh"
 
 namespace blender::bnpr
-- 
2.38.1.windows.1


From 66d94f9de7500eb324655a82abea6bf5804c27f2 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Tue, 6 Dec 2022 23:22:44 +0800
Subject: [PATCH 06/11] Finished empty compute shader compilation process

shader create info:
1) add directory to the cmakelist
2) add create info .hh to the cmakelist
3) I wrote some explanation in "bnpr_test_info.hh"
---
 source/blender/draw/CMakeLists.txt            | 15 ++--
 .../blender/draw/engines/bnpr/bnpr_defines.hh |  4 +-
 .../draw/engines/bnpr/bnpr_instance.hh        | 12 ++-
 .../blender/draw/engines/bnpr/bnpr_shader.cc  |  2 +
 .../blender/draw/engines/bnpr/bnpr_shader.hh  |  3 +-
 .../draw/engines/bnpr/bnpr_shader_shared.hh   | 90 ++++++++++++++++++-
 .../bnpr/bnpr_strokegen_buffer_pool.cc        | 25 ++++++
 .../bnpr/bnpr_strokegen_buffer_pool.hh        | 37 ++++++++
 .../draw/engines/bnpr/bnpr_strokegen_pass.cc  | 34 +++++++
 .../draw/engines/bnpr/bnpr_strokegen_pass.hh  | 56 ++++++++++++
 .../bnpr/bnpr_strokegen_texture_pool.cc       | 15 ++++
 .../bnpr/bnpr_strokegen_texture_pool.hh       | 35 ++++++++
 source/blender/draw/engines/bnpr/bnpr_sync.cc |  6 --
 source/blender/draw/engines/bnpr/bnpr_sync.hh |  2 +
 .../shaders/bnpr_strokegen_test_comp.glsl     | 57 ++++++++++++
 .../bnpr/shaders/infos/bnpr_test_info.hh      | 68 ++++++++++++++
 .../shaders/infos/strokegen_depth_info.hh     | 65 --------------
 source/blender/gpu/CMakeLists.txt             |  3 +
 18 files changed, 445 insertions(+), 84 deletions(-)
 create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
 create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
 create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
 create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
 create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.cc
 create mode 100644 source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
 create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
 create mode 100644 source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
 delete mode 100644 source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh

diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
index 3402caa5f23..e6885e1958d 100644
--- a/source/blender/draw/CMakeLists.txt
+++ b/source/blender/draw/CMakeLists.txt
@@ -212,8 +212,9 @@ set(SRC
   engines/bnpr/bnpr_shader.cc
   engines/bnpr/bnpr_instance.cc
   engines/bnpr/bnpr_sync.cc
-
-
+  engines/bnpr/bnpr_strokegen_buffer_pool.cc
+  engines/bnpr/bnpr_strokegen_texture_pool.cc
+  engines/bnpr/bnpr_strokegen_pass.cc
 
 
 
@@ -310,6 +311,9 @@ set(SRC
   engines/bnpr/bnpr_instance.hh
   engines/bnpr/bnpr_sync_handles.hh
   engines/bnpr/bnpr_sync.hh
+  engines/bnpr/bnpr_strokegen_buffer_pool.hh
+  engines/bnpr/bnpr_strokegen_texture_pool.hh
+  engines/bnpr/bnpr_strokegen_pass.hh
 )
 
 set(LIB
@@ -700,15 +704,10 @@ set(GLSL_SRC
   engines/image/shaders/image_engine_depth_frag.glsl
   engines/image/shaders/image_engine_depth_vert.glsl
 
-
-
-
-
+  engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
 
   engines/bnpr/bnpr_defines.hh
   engines/bnpr/bnpr_shader_shared.hh
-
-
 )
 
 set(GLSL_C)
diff --git a/source/blender/draw/engines/bnpr/bnpr_defines.hh b/source/blender/draw/engines/bnpr/bnpr_defines.hh
index dfd63e92d97..1ffca605ca9 100644
--- a/source/blender/draw/engines/bnpr/bnpr_defines.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_defines.hh
@@ -9,5 +9,7 @@
  * dragging larger headers into the createInfo pipeline which would cause problems.
  */
 
-
 #pragma once
+
+
+#define GROUP_SIZE_STROKEGEN_TEST 512
diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.hh b/source/blender/draw/engines/bnpr/bnpr_instance.hh
index 5f6a7374b89..54517634682 100644
--- a/source/blender/draw/engines/bnpr/bnpr_instance.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.hh
@@ -23,7 +23,9 @@
 #include "draw_pass.hh"
 #include "bnpr_shader.hh"
 #include "bnpr_sync.hh"
-
+#include "bnpr_strokegen_buffer_pool.hh"
+#include "bnpr_strokegen_texture_pool.hh"
+#include "bnpr_strokegen_pass.hh"
 
 namespace blender::bnpr
 {
@@ -37,6 +39,9 @@ namespace blender::bnpr
     /** Shading Modules */
     ShaderModule shaders; // singleton class for handling GPUShader(s)
     SyncModule sync;
+    GPUBufferPoolModule   strokegen_buffers;
+    GPUTexturePoolModule  strokegen_textures;
+    StrokeGenPassModule   strokegen_passes;
 
     /** Input data. */
     Depsgraph *depsgraph;
@@ -65,7 +70,10 @@ namespace blender::bnpr
   public:
     Instance() :
     shaders(*ShaderModule::module_get()),
-    sync(*this)
+    sync(*this),
+    strokegen_buffers(*this),
+    strokegen_textures(*this),
+    strokegen_passes(shaders, strokegen_buffers, strokegen_textures)
     {
     };
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.cc b/source/blender/draw/engines/bnpr/bnpr_shader.cc
index 7bf72caf057..75cc42e3c09 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_shader.cc
@@ -90,6 +90,8 @@ const char *ShaderModule::static_shader_create_info_name_get(eShaderType shader_
       return "basic_depth_mesh_conservative";
     case POINTCLOUD_DEPTH_CONSERVATIVE:
       return "basic_depth_pointcloud_conservative";
+    case COMPUTE_TEST:
+      return "bnpr_strokegen_test";
 
     /* To avoid compiler warning about missing case. */
     case MAX_SHADER_TYPE:
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.hh b/source/blender/draw/engines/bnpr/bnpr_shader.hh
index 9b756e213a4..ff758760c22 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader.hh
@@ -24,7 +24,8 @@ namespace blender::bnpr {
 
 /* Keep alphabetical order and clean prefix. */
 enum eShaderType {
-  DEPTH = 0,
+  COMPUTE_TEST = 0,
+  DEPTH,
   POINTCLOUD_DEPTH,
   CURVES_DEPTH,
   DEPTH_CONSERVATIVE,
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
index 9cbb254e58c..4a33610836a 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
@@ -6,4 +6,92 @@
  * language.
  */
 
-#pragma once
+#ifndef USE_GPU_SHADER_CREATE_INFO
+#  pragma once
+
+#  include "BLI_memory_utils.hh"
+#  include "DRW_gpu_wrapper.hh"
+
+#  include "draw_manager.hh"
+#  include "draw_pass.hh"
+
+#  include "bnpr_defines.hh"
+
+#  include "GPU_shader_shared.h"
+
+namespace blender::bnpr {
+
+using namespace draw;
+
+constexpr eGPUSamplerState no_filter = GPU_SAMPLER_DEFAULT;
+constexpr eGPUSamplerState with_filter = GPU_SAMPLER_FILTER;
+
+#endif
+
+
+
+#define UBO_MIN_MAX_SUPPORTED_SIZE 1 << 14
+
+/* -------------------------------------------------------------------- */
+/** \name Debug Mode
+ * \{ */
+
+/** These are just to make more sense of G.debug_value's values. Reserved range is 1-30. */
+enum eDebugMode : uint32_t {
+  DEBUG_NONE = 0u,
+  /**
+   * Gradient showing light evaluation hot-spots.
+   */
+  DEBUG_LIGHT_CULLING = 1u,
+  /**
+   * Show incorrectly downsample tiles in red.
+   */
+  DEBUG_HIZ_VALIDATION = 2u,
+  /**
+   * Tile-maps to screen. Is also present in other modes.
+   * - Black pixels, no pages allocated.
+   * - Green pixels, pages cached.
+   * - Red pixels, pages allocated.
+   */
+  DEBUG_SHADOW_TILEMAPS = 10u,
+  /**
+   * Random color per pages. Validates page density allocation and sampling.
+   */
+  DEBUG_SHADOW_PAGES = 11u,
+  /**
+   * Outputs random color per tile-map (or tile-map level). Validates tile-maps coverage.
+   * Black means not covered by any tile-maps LOD of the shadow.
+   */
+  DEBUG_SHADOW_LOD = 12u,
+  /**
+   * Outputs white pixels for pages allocated and black pixels for unused pages.
+   * This needs DEBUG_SHADOW_PAGE_ALLOCATION_ENABLED defined in order to work.
+   */
+  DEBUG_SHADOW_PAGE_ALLOCATION = 13u,
+  /**
+   * Outputs the tile-map atlas. Default tile-map is too big for the usual screen resolution.
+   * Try lowering SHADOW_TILEMAP_PER_ROW and SHADOW_MAX_TILEMAP before using this option.
+   */
+  DEBUG_SHADOW_TILE_ALLOCATION = 14u,
+  /**
+   * Visualize linear depth stored in the atlas regions of the active light.
+   * This way, one can check if the rendering, the copying and the shadow sampling functions works.
+   */
+  DEBUG_SHADOW_SHADOW_DEPTH = 15u
+};
+/** \} */
+
+
+
+
+#ifdef __cplusplus
+
+// Template to set buffer size in compile time
+using StrokeGenTestBuf = draw::StorageArrayBuffer<uint, 4096, true>;
+
+
+}
+
+
+// namespace blender::bnpr
+#endif
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
new file mode 100644
index 00000000000..39d96265894
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
@@ -0,0 +1,25 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup bnpr
+ */
+
+#include "bnpr_strokegen_buffer_pool.hh"
+#include "bnpr_instance.hh"
+
+namespace blender::bnpr
+{
+  void GPUBufferPoolModule::sync(Object* object)
+  {
+  }
+
+  void GPUBufferPoolModule::end_sync()
+  {
+    // arr_buf_test_.resize(4096); // maybe needed for a few special buffers
+  }
+
+
+
+}
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
new file mode 100644
index 00000000000..7c2e58abe49
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
@@ -0,0 +1,37 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup bnpr
+ */
+
+#pragma once
+
+#include "bnpr_shader_shared.hh"
+
+namespace blender::bnpr
+{
+  class Instance;
+
+  class GPUBufferPoolModule
+  {
+    friend class StrokeGenPassModule;
+
+  private:
+    /** Compute Resources */
+    StrokeGenTestBuf arr_buf_test_;
+
+    /** Instance */
+    Instance &instance;
+
+
+  public:
+    GPUBufferPoolModule(Instance &inst) : instance(inst) {};
+    ~GPUBufferPoolModule() {};
+
+    void sync(Object* object);
+    void end_sync();
+
+  };
+}
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
new file mode 100644
index 00000000000..44a2c7bc6db
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
@@ -0,0 +1,34 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup bnpr
+ *
+ */
+
+#include "bnpr_strokegen_pass.hh"
+
+namespace blender::bnpr
+{
+  using namespace blender;
+
+
+  void StrokeGenPassModule::sync_(
+    GPUBufferPoolModule& strokegen_buffers,
+    GPUTexturePoolModule& strokegen_texture_pool)
+  {
+    pass_comp_test.init();
+    {
+      auto& sub = pass_comp_test.sub("strokegen_comp_test_subpass");
+      sub.shader_set(shaders_.static_shader_get(eShaderType::COMPUTE_TEST));
+      sub.bind_ssbo("buf_test", strokegen_buffers.arr_buf_test_);
+      sub.dispatch(int3(32, 1, 1));
+      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+    }
+  }
+
+  void StrokeGenPassModule::end_sync_()
+  {
+  }
+}
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
new file mode 100644
index 00000000000..c6335e57dd9
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
@@ -0,0 +1,56 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup bnpr
+ */
+
+#pragma once
+
+#include "draw_pass.hh"
+#include "draw_manager.hh"
+
+#include "bnpr_shader.hh"
+#include "bnpr_shader_shared.hh"
+#include "bnpr_strokegen_buffer_pool.hh"
+#include "bnpr_strokegen_texture_pool.hh"
+#include "bnpr_strokegen_pass.hh"
+
+namespace blender::bnpr
+{
+  class Instance;
+
+  class StrokeGenPassModule // similar to "LineDrawingRenderPass"
+  {
+  private:
+    /** Compute Passes */
+    draw::PassSimple pass_comp_test = {"Strokegen Compute Test"};
+
+    /** Instance */
+    ShaderModule &shaders_;
+    GPUBufferPoolModule& buffers_;
+    GPUTexturePoolModule& textures_;
+
+    void sync_(GPUBufferPoolModule& strokegen_buffers, GPUTexturePoolModule& strokegen_texture_pool);
+    void end_sync_();
+
+
+  public:
+    StrokeGenPassModule(
+      ShaderModule          &strokegen_shaders,
+      GPUBufferPoolModule   &instance_buffers,
+      GPUTexturePoolModule  &strokegen_textures
+    ) :
+      shaders_(strokegen_shaders),
+      buffers_(instance_buffers),
+      textures_(strokegen_textures)
+    {};
+
+    ~StrokeGenPassModule() {};
+
+    void sync() { sync_(buffers_, textures_); }
+    void end_sync() { end_sync_(); }
+  };
+}
+
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.cc
new file mode 100644
index 00000000000..002a9d2b4b0
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.cc
@@ -0,0 +1,15 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup bnpr
+ */
+
+#include "bnpr_strokegen_texture_pool.hh"
+#include "bnpr_instance.hh"
+
+namespace blender::bnpr
+{
+
+}
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
new file mode 100644
index 00000000000..9250260ce83
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
@@ -0,0 +1,35 @@
+Ôªø/* SPDX-License-Identifier: GPL-2.0-or-later
+* Copyright 2021 Blender Foundation.
+ */
+
+/** \file
+ * \ingroup bnpr
+ */
+
+#pragma once
+
+#include "bnpr_shader_shared.hh"
+
+namespace blender::bnpr
+{
+  class Instance;
+
+  class GPUTexturePoolModule
+  {
+  private:
+    /** Compute Resources */
+    StrokeGenTestBuf arr_buf_test_;
+
+    /** Instance */
+    Instance &instance;
+
+
+  public:
+    GPUTexturePoolModule(Instance &inst) : instance(inst) {};
+    ~GPUTexturePoolModule() {};
+
+    void sync(Object* object) {};
+    void end_sync() {};
+
+  };
+}
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
index 5bff2b58f9e..0bf3e988214 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
@@ -35,11 +35,5 @@ namespace blender::bnpr
     dd->recalc = ID_RECALC_ALL; /* Tag given ID for an update in all the dependency graphs. */
   }
 
-  // ObjectHandle& SyncModule::sync_object(Object* ob)
-  // {
-  //   DrawEngineType *owner = (DrawEngineType *)&DRW_engine_viewport_bnpr_type;
-  //   return ObjectHandle();
-  // }
-
 
 }
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
index b16e3dda61f..696559fcc48 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
@@ -44,6 +44,8 @@ namespace blender::bnpr
                    const draw::ObjectRef &ob_ref) {};
   };
 
+
+
 }
 
 
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
new file mode 100644
index 00000000000..4bec9ae766b
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
@@ -0,0 +1,57 @@
+
+/**
+ * Sort the lights by their Z distance to the camera.
+ * Outputs ordered light buffer.
+ * One thread processes one Light entity.
+ */
+
+// #pragma BLENDER_REQUIRE(common_math_lib.glsl)
+
+uint buf_test[/*gl_WorkGroupSize.x*/4096];
+
+void main()
+{
+  // uint src_index = gl_GlobalInvocationID.x;
+  // bool valid_thread = true;
+//
+  // if (src_index >= light_cull_buf.visible_count) {
+  //   /* Do not return because we use barriers later on (which need uniform control flow).
+  //    * Just process the same last item but avoid insertion. */
+  //   src_index = light_cull_buf.visible_count - 1;
+  //   valid_thread = false;
+  // }
+//
+  // float local_zdist = in_zdist_buf[src_index];
+//
+  // int prefix_sum = 0;
+  // /* Iterate over the whole key buffer. */
+  // uint iter = divide_ceil(light_cull_buf.visible_count, gl_WorkGroupSize.x);
+  // for (uint i = 0u; i < iter; i++) {
+  //   uint index = gl_WorkGroupSize.x * i + gl_LocalInvocationID.x;
+  //   /* NOTE: This will load duplicated values, but they will be discarded. */
+  //   index = min(index, light_cull_buf.visible_count - 1);
+  //   zdists_cache[gl_LocalInvocationID.x] = in_zdist_buf[index];
+//
+  //   barrier();
+//
+  //   /* Iterate over the cache line. */
+  //   uint line_end = min(gl_WorkGroupSize.x, light_cull_buf.visible_count - gl_WorkGroupSize.x * i);
+  //   for (uint j = 0u; j < line_end; j++) {
+  //     if (zdists_cache[j] < local_zdist) {
+  //       prefix_sum++;
+  //     }
+  //     else if (zdists_cache[j] == local_zdist) {
+  //       /* Same depth, use index to order and avoid same prefix for 2 different lights. */
+  //       if ((gl_WorkGroupSize.x * i + j) < src_index) {
+  //         prefix_sum++;
+  //       }
+  //     }
+  //   }
+  // }
+//
+  // if (valid_thread) {
+  //   /* Copy sorted light to render light buffer. */
+  //   uint input_index = in_key_buf[src_index];
+  //   out_light_buf[prefix_sum] = in_light_buf[input_index];
+  // }
+}
diff --git a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
new file mode 100644
index 00000000000..0d1f735983d
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
@@ -0,0 +1,68 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#include "bnpr_defines.hh"
+#include "gpu_shader_create_info.hh"
+
+/* -------------------------------------------------------------------- */
+/** \name Tutorial
+ * \{ */
+
+/* For details, see "gpu_shader_create_info.hh" */
+// GPU_SHADER_CREATE_INFO(bnpr_strokegen_test_comp)
+  // .do_static_compilation(true)
+
+  /* -------------------------------------------------------------------- */
+  /* Name of other infos to recursively merge with this one.
+   * No data slot must overlap otherwise we throw an error. */
+  // .additional_info("eevee_shared", "draw_view", "draw_view_culling")
+  // .define("DOF_BOKEH_TEXTURE", "false")
+
+  /* -------------------------------------------------------------------- */
+  /** Resources bindings points
+  // .uniform_buf(6, "DepthOfFieldData", "dof_buf")
+  // .storage_buf(0, Qualifier::READ_WRITE, "LightCullingData", "light_cull_buf")
+  // .storage_buf(1, Qualifier::READ, "LightData", "in_light_buf[]")
+  // .storage_buf(2, Qualifier::WRITE, "LightData", "out_light_buf[]")
+  // .sampler(0, ImageType::FLOAT_2D, "downsample_tx")
+  // .image(0, GPU_RGBA16F, Qualifier::READ_WRITE, ImageType::FLOAT_2D, "inout_color_lod0_img")
+  /*          eGPUTextureFormat                     ImageType  */
+
+  /* -------------------------------------------------------------------- */
+  /** Comptue shader
+  // .local_group_size(CULLING_SELECT_GROUP_SIZE) /* <== from "bnpr_defines.hh" */
+  // .compute_source("eevee_light_culling_select_comp.glsl");
+
+  /* -------------------------------------------------------------------- */
+  // Vertex & Fragment shader
+  // .vertex_in(0, Type::VEC3, "pos")
+  // .vertex_in(1, Type::VEC3, "nor")
+  // .vertex_source("eevee_geom_mesh_vert.glsl")
+  //
+  // .fragment_out(0, Type::VEC4, "out_radiance", DualBlend::SRC_0)
+  // .fragment_out(1, Type::VEC4, "out_transmittance", DualBlend::SRC_1)
+  // .fragment_source("eevee_surf_forward_frag.glsl")
+  //
+  /* In order to use .vertex_out for vs output,
+   * we firstly need to define an interface:
+// GPU_SHADER_INTERFACE_INFO(interface_info_name, "interp")
+  // .smooth(Type::VEC3, "a") /* smooth: conventional interpolation for fragments */
+  // .flat(Type::VEC3, "b"); /* flat: no interpolation, instead, use attribute from a "provoking vertex" */
+  // .noperspective(Type::VEC3, "c") /* interpolation, without perspective correction */
+  /* Then use the interface to declare a .vertex_out: */
+  // .vertex_out(interface_info_name)
+
+/** \} */
+
+
+
+
+/* -------------------------------------------------------------------- */
+/** \test
+ * \{ */
+GPU_SHADER_CREATE_INFO(bnpr_strokegen_test)
+  .do_static_compilation(true)
+  .storage_buf(0, Qualifier::READ_WRITE, "uint", "buf_test")
+  .local_group_size(GROUP_SIZE_STROKEGEN_TEST) /* <== from "bnpr_defines.hh" */
+  .compute_source("bnpr_strokegen_test_comp.glsl");
+
+/** \} */
diff --git a/source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh
deleted file mode 100644
index e275d208c7a..00000000000
--- a/source/blender/draw/engines/bnpr/shaders/infos/strokegen_depth_info.hh
+++ /dev/null
@@ -1,65 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-or-later */
-
-#include "gpu_shader_create_info.hh"
-
-/* -------------------------------------------------------------------- */
-/** \name Conservative Rasterization
- *
- * Allow selection of sub-pixel objects.
- * \{ */
-
-GPU_SHADER_CREATE_INFO(basic_conservative)
-    .geometry_layout(PrimitiveIn::TRIANGLES, PrimitiveOut::TRIANGLE_STRIP, 3)
-    .geometry_source("basic_conservative_depth_geom.glsl");
-
-/** \} */
-
-/* -------------------------------------------------------------------- */
-/** \name Object types
- * \{ */
-
-GPU_SHADER_CREATE_INFO(basic_mesh)
-    .vertex_in(0, Type::VEC3, "pos")
-    .vertex_source("basic_depth_vert.glsl")
-    .additional_info("draw_mesh");
-
-GPU_SHADER_CREATE_INFO(basic_pointcloud)
-    .vertex_source("basic_depth_pointcloud_vert.glsl")
-    .additional_info("draw_pointcloud");
-
-GPU_SHADER_CREATE_INFO(basic_curves)
-    .vertex_source("basic_depth_curves_vert.glsl")
-    .additional_info("draw_hair");
-/** \} */
-
-/* -------------------------------------------------------------------- */
-/** \name Variations Declaration
- * \{ */
-
-#define BASIC_FINAL_VARIATION(name, ...) \
-  GPU_SHADER_CREATE_INFO(name).additional_info(__VA_ARGS__).do_static_compilation(true);
-
-#define BASIC_CLIPPING_VARIATIONS(prefix, ...) \
-  BASIC_FINAL_VARIATION(prefix##_clipped, "drw_clipped", __VA_ARGS__) \
-  BASIC_FINAL_VARIATION(prefix, __VA_ARGS__)
-
-#define BASIC_CONSERVATIVE_VARIATIONS(prefix, ...) \
-  BASIC_CLIPPING_VARIATIONS(prefix##_conservative, "basic_conservative", __VA_ARGS__) \
-  BASIC_CLIPPING_VARIATIONS(prefix, __VA_ARGS__)
-
-#define BASIC_OBTYPE_VARIATIONS(prefix, ...) \
-  BASIC_CONSERVATIVE_VARIATIONS(prefix##_mesh, "basic_mesh", __VA_ARGS__) \
-  BASIC_CONSERVATIVE_VARIATIONS(prefix##_pointcloud, "basic_pointcloud", __VA_ARGS__) \
-  BASIC_CLIPPING_VARIATIONS(prefix##_curves, "basic_curves", __VA_ARGS__)
-
-/** \} */
-
-/* -------------------------------------------------------------------- */
-/** \name Depth shader types.
- * \{ */
-
-GPU_SHADER_CREATE_INFO(basic_depth).fragment_source("basic_depth_frag.glsl");
-
-BASIC_OBTYPE_VARIATIONS(basic_depth, "basic_depth", "draw_globals");
-
-/** \} */
diff --git a/source/blender/gpu/CMakeLists.txt b/source/blender/gpu/CMakeLists.txt
index 02793fa74be..326ff061138 100644
--- a/source/blender/gpu/CMakeLists.txt
+++ b/source/blender/gpu/CMakeLists.txt
@@ -29,6 +29,7 @@ set(INC
   # For *_info.hh includes.
   ../compositor/realtime_compositor
   ../draw/engines/eevee_next
+  ../draw/engines/bnpr
   ../draw/intern
 
   # For node muting stuff.
@@ -590,6 +591,8 @@ set(SRC_SHADER_CREATE_INFOS
   ../draw/engines/eevee/shaders/infos/eevee_legacy_volume_info.hh
 
   ../draw/engines/image/shaders/infos/engine_image_info.hh
+
+  ../draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
   ../draw/intern/shaders/draw_debug_info.hh
   ../draw/intern/shaders/draw_fullscreen_info.hh
   ../draw/intern/shaders/draw_hair_refine_info.hh
-- 
2.38.1.windows.1


From 1a95c1f492f07cb50eb6a6ca1458e0966012c3c0 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sun, 11 Dec 2022 19:39:06 +0800
Subject: [PATCH 07/11] Add sync_object

to sync a mesh, I need a material module
---
 .../bnpr/bnpr_strokegen_buffer_pool.hh        |  6 ++---
 .../draw/engines/bnpr/bnpr_strokegen_pass.hh  |  4 ++--
 .../bnpr/bnpr_strokegen_texture_pool.hh       | 12 +++++-----
 source/blender/draw/engines/bnpr/bnpr_sync.cc | 22 +++++++++++++++++--
 source/blender/draw/engines/bnpr/bnpr_sync.hh |  2 +-
 .../draw/engines/bnpr/bnpr_sync_handles.hh    |  3 +--
 6 files changed, 34 insertions(+), 15 deletions(-)

diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
index 7c2e58abe49..c821086ae5d 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
@@ -19,12 +19,12 @@ namespace blender::bnpr
     friend class StrokeGenPassModule;
 
   private:
-    /** Compute Resources */
-    StrokeGenTestBuf arr_buf_test_;
-
     /** Instance */
     Instance &instance;
 
+    /** Compute Resources */
+    StrokeGenTestBuf arr_buf_test_;
+
 
   public:
     GPUBufferPoolModule(Instance &inst) : instance(inst) {};
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
index c6335e57dd9..3848a035fc9 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
@@ -39,11 +39,11 @@ namespace blender::bnpr
   public:
     StrokeGenPassModule(
       ShaderModule          &strokegen_shaders,
-      GPUBufferPoolModule   &instance_buffers,
+      GPUBufferPoolModule   &strokegen_buffers,
       GPUTexturePoolModule  &strokegen_textures
     ) :
       shaders_(strokegen_shaders),
-      buffers_(instance_buffers),
+      buffers_(strokegen_buffers),
       textures_(strokegen_textures)
     {};
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
index 9250260ce83..25a1b6612f3 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_texture_pool.hh
@@ -17,15 +17,17 @@ namespace blender::bnpr
   class GPUTexturePoolModule
   {
   private:
-    /** Compute Resources */
-    StrokeGenTestBuf arr_buf_test_;
-
     /** Instance */
-    Instance &instance;
+    Instance &instance_;
+
+    /** Compute Resources */
+    TextureFromPool strokegen_tex_test_;
 
 
   public:
-    GPUTexturePoolModule(Instance &inst) : instance(inst) {};
+    GPUTexturePoolModule(Instance &inst) :
+      instance_(inst),
+      strokegen_tex_test_("StrokegenTexture_Test"){};
     ~GPUTexturePoolModule() {};
 
     void sync(Object* object) {};
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
index 0bf3e988214..e8201ebad65 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
@@ -23,17 +23,35 @@
 
 namespace blender::bnpr
 {
-
   /* -------------------------------------------------------------------- */
   /** \name Draw Data
    *
    * \{ */
 
-  static void draw_data_init_cb(struct DrawData *dd)
+  static void draw_data_init_cb(struct DrawData* dd)
   {
     /* Object has just been created or was never evaluated by the engine. */
     dd->recalc = ID_RECALC_ALL; /* Tag given ID for an update in all the dependency graphs. */
   }
 
 
+  ObjectHandle& SyncModule::sync_object(Object* ob)
+  {
+    DrawEngineType* owner = (DrawEngineType*)&DRW_engine_viewport_bnpr_type;
+    struct DrawData* dd = DRW_drawdata_ensure(
+      (ID*)ob, owner, sizeof(ObjectHandle), draw_data_init_cb, nullptr);
+
+    ObjectHandle &dd_bnpr = *reinterpret_cast<ObjectHandle*>(dd); // draw-engine specific draw data.
+
+    if (dd_bnpr.object_key.ob == nullptr)
+    {
+      dd_bnpr.object_key = ObjectKey(ob);
+    }
+
+
+    return dd_bnpr;
+  }
+
+
+
 }
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
index 696559fcc48..4b8ca2a1656 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
@@ -34,7 +34,7 @@ namespace blender::bnpr
     SyncModule(Instance &inst) : inst_(inst) {};
     ~SyncModule(){};
 
-    ObjectHandle &sync_object(Object *ob) {};
+    ObjectHandle &sync_object(Object *ob);
     WorldHandle &sync_world(::World *world) {};
     SceneHandle &sync_scene(::Scene *scene) {};
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh b/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
index 8fd0fc90070..3560f7a3926 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_sync_handles.hh
@@ -125,8 +125,7 @@ namespace blender::bnpr
   /** \} */
 
   /* -------------------------------------------------------------------- */
-  /** \name Sync Module
-   *
+  /** \name Engine-Specific Draw-Data
    * \{ */
 
   struct ObjectHandle : public DrawData
-- 
2.38.1.windows.1


From aeb4fd04eeceaa63b77566011e1d876318760edb Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Mon, 12 Dec 2022 00:06:55 +0800
Subject: [PATCH 08/11] Experiment with mesh_sync and actual shader dispatch.

1) Compute dispatch does not run since we haven't implemented
instance->draw_viewport yet.
2) mesh_sync calls dispatch, but requires the draw manager to submit the passes including the compute shaders, and submission should happen in instance->draw_viewport
---
 .../draw/engines/bnpr/bnpr_instance.cc        | 34 +++++++++++++++++--
 .../draw/engines/bnpr/bnpr_strokegen_pass.cc  | 12 +++----
 .../draw/engines/bnpr/bnpr_strokegen_pass.hh  | 10 +++---
 source/blender/draw/engines/bnpr/bnpr_sync.cc | 24 +++++++++++++
 source/blender/draw/engines/bnpr/bnpr_sync.hh |  2 +-
 .../shaders/bnpr_strokegen_test_comp.glsl     |  4 +--
 6 files changed, 67 insertions(+), 19 deletions(-)

diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.cc b/source/blender/draw/engines/bnpr/bnpr_instance.cc
index 5139b0c5f49..2bb9985950d 100644
--- a/source/blender/draw/engines/bnpr/bnpr_instance.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.cc
@@ -81,8 +81,38 @@ namespace blender::bnpr
   }
 
   void Instance::object_sync(Manager& manager, ObjectRef& object_ref)
-  {
-    /* Add object draw calls to passes. (Populate render graph) */
+  { /* Add object draw calls to passes. (Populate render graph) */
+    Object *ob = object_ref.object;
+
+    const bool is_renderable_type = ELEM(ob->type, OB_CURVES, OB_GPENCIL, OB_MESH, OB_LAMP);
+    const int ob_visibility = DRW_object_visibility_in_active_context(ob);
+    const bool partsys_is_visible = (ob_visibility & OB_VISIBLE_PARTICLES) != 0 &&
+                                    (ob->type == OB_MESH);
+    const bool object_is_visible = DRW_object_is_renderable(ob) &&
+                                   (ob_visibility & OB_VISIBLE_SELF) != 0;
+
+    if (!is_renderable_type || (!partsys_is_visible && !object_is_visible)) {
+      return;
+    }
+
+    /* fclem: TODO cleanup. */
+    ObjectRef ob_ref = DRW_object_ref_get(ob);
+    ResourceHandle res_handle = manager.resource_handle(ob_ref);
+
+    ObjectHandle &ob_handle = sync.sync_object(ob);
+
+
+    if (object_is_visible) {
+      switch (ob->type) {
+      case OB_MESH:
+        sync.sync_mesh(ob, ob_handle, res_handle, ob_ref);
+        break;
+      default:
+        break;
+      }
+    }
+
+    ob_handle.reset_recalc_flag();
   }
 
   void Instance::end_sync(Manager&)
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
index 44a2c7bc6db..ec1d4f33f10 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
@@ -13,22 +13,18 @@ namespace blender::bnpr
 {
   using namespace blender;
 
-
-  void StrokeGenPassModule::sync_(
-    GPUBufferPoolModule& strokegen_buffers,
-    GPUTexturePoolModule& strokegen_texture_pool)
+  void StrokeGenPassModule::dispatch_extract_mesh_contour(Object* ob)
   {
     pass_comp_test.init();
     {
       auto& sub = pass_comp_test.sub("strokegen_comp_test_subpass");
       sub.shader_set(shaders_.static_shader_get(eShaderType::COMPUTE_TEST));
-      sub.bind_ssbo("buf_test", strokegen_buffers.arr_buf_test_);
+      sub.bind_ssbo("buf_test", buffers_.arr_buf_test_);
       sub.dispatch(int3(32, 1, 1));
       sub.barrier(GPU_BARRIER_SHADER_STORAGE);
     }
   }
 
-  void StrokeGenPassModule::end_sync_()
-  {
-  }
+
+
 }
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
index 3848a035fc9..edd4d92edfb 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
@@ -32,9 +32,6 @@ namespace blender::bnpr
     GPUBufferPoolModule& buffers_;
     GPUTexturePoolModule& textures_;
 
-    void sync_(GPUBufferPoolModule& strokegen_buffers, GPUTexturePoolModule& strokegen_texture_pool);
-    void end_sync_();
-
 
   public:
     StrokeGenPassModule(
@@ -49,8 +46,11 @@ namespace blender::bnpr
 
     ~StrokeGenPassModule() {};
 
-    void sync() { sync_(buffers_, textures_); }
-    void end_sync() { end_sync_(); }
+    /** Passes Batched by Usages */
+    void dispatch_extract_mesh_contour(Object* ob);
+
+
+
   };
 }
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
index e8201ebad65..8c94eed402b 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
@@ -21,6 +21,9 @@
 #include "bnpr_instance.hh"
 #include "bnpr_sync.hh"
 
+#include "draw_cache_extract.hh"
+#include "draw_cache_impl.h"
+
 namespace blender::bnpr
 {
   /* -------------------------------------------------------------------- */
@@ -52,6 +55,27 @@ namespace blender::bnpr
     return dd_bnpr;
   }
 
+  void SyncModule::sync_mesh(
+    Object* ob, ObjectHandle& ob_handle,
+    draw::ResourceHandle res_handle, const draw::ObjectRef& ob_ref
+  )
+  {
+    bool mesh_is_manifold;
+    GPUBatch *geobatch = DRW_cache_object_edge_detection_get(ob, &mesh_is_manifold);
+
+    if (geobatch == nullptr) return;
 
+    // Old way to do this:
+    // See "draw_subdiv_build_tris_buffer"
+    // const char *defines = "#define XXX\n";
+    // GPUShader *shader = get_strokegen_shader(...)
+    //
+    // eevvee_next way to do this:
+    //  strokegen_passes.dispatch_extract_mesh_contour(ob);
+    //  strokegen_passes.dispatch_XXX(...);
+    //  ... ... ...
+    inst_.strokegen_passes.dispatch_extract_mesh_contour(ob);
 
+
+  }
 }
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.hh b/source/blender/draw/engines/bnpr/bnpr_sync.hh
index 4b8ca2a1656..974b162092d 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.hh
@@ -41,7 +41,7 @@ namespace blender::bnpr
     void sync_mesh(Object *ob,
                    ObjectHandle &ob_handle,
                    draw::ResourceHandle res_handle,
-                   const draw::ObjectRef &ob_ref) {};
+                   const draw::ObjectRef &ob_ref);
   };
 
 
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
index 4bec9ae766b..5d0304865db 100644
--- a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
@@ -5,9 +5,7 @@
  * One thread processes one Light entity.
  */
 
-// #pragma BLENDER_REQUIRE(common_math_lib.glsl)
-
-uint buf_test[/*gl_WorkGroupSize.x*/4096];
+#pragma BLENDER_REQUIRE(gpu_shader_codegen_lib.glsl)
 
 void main()
 {
-- 
2.38.1.windows.1


From a5e0a0429066c6d0fd22dda96dba68f97c80ea39 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Wed, 21 Dec 2022 22:21:56 +0800
Subject: [PATCH 09/11] submit test compute pass

---
 .../draw/engines/bnpr/bnpr_instance.cc        | 10 ++--
 .../draw/engines/bnpr/bnpr_instance.hh        |  2 +-
 .../blender/draw/engines/bnpr/bnpr_shader.cc  |  2 +-
 .../draw/engines/bnpr/bnpr_shader_shared.hh   | 58 -------------------
 .../bnpr/bnpr_strokegen_buffer_pool.hh        |  2 +-
 .../draw/engines/bnpr/bnpr_strokegen_pass.cc  |  4 +-
 .../draw/engines/bnpr/bnpr_strokegen_pass.hh  | 14 ++++-
 source/blender/draw/engines/bnpr/bnpr_sync.cc |  2 +-
 .../shaders/bnpr_strokegen_test_comp.glsl     | 48 +--------------
 .../bnpr/shaders/infos/bnpr_test_info.hh      |  8 ++-
 10 files changed, 32 insertions(+), 118 deletions(-)

diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.cc b/source/blender/draw/engines/bnpr/bnpr_instance.cc
index 2bb9985950d..46be7fd8d31 100644
--- a/source/blender/draw/engines/bnpr/bnpr_instance.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.cc
@@ -80,6 +80,11 @@ namespace blender::bnpr
     /* Init draw passes and manager related stuff. (Begin render graph) */
   }
 
+  void Instance::end_sync(Manager&)
+  {
+    /* Post processing after all object. (End render graph) */
+  }
+
   void Instance::object_sync(Manager& manager, ObjectRef& object_ref)
   { /* Add object draw calls to passes. (Populate render graph) */
     Object *ob = object_ref.object;
@@ -115,10 +120,6 @@ namespace blender::bnpr
     ob_handle.reset_recalc_flag();
   }
 
-  void Instance::end_sync(Manager&)
-  {
-    /* Post processing after all object. (End render graph) */
-  }
 
   /** \} */
 
@@ -135,6 +136,7 @@ namespace blender::bnpr
     GPUTexture* color_tx)
   {
     /* Submit passes here. (Execute render graph) */
+    manager.submit(strokegen_passes.get_compute_pass(StrokeGenPassModule::eType::EXTRACT_MESH_CONTOUR), view);
   }
 
   /** \} */
diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.hh b/source/blender/draw/engines/bnpr/bnpr_instance.hh
index 54517634682..6d7532c8ea3 100644
--- a/source/blender/draw/engines/bnpr/bnpr_instance.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.hh
@@ -82,10 +82,10 @@ namespace blender::bnpr
     void update_eval_members();
 
     void begin_sync(Manager& manager);
+    void end_sync(Manager& manager);
 
     void object_sync(Manager& manager, ObjectRef& object_ref);
 
-    void end_sync(Manager& /* manager */);
 
     void draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
                        GPUTexture* color_tx);
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.cc b/source/blender/draw/engines/bnpr/bnpr_shader.cc
index 75cc42e3c09..c77bc4675fa 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_shader.cc
@@ -91,7 +91,7 @@ const char *ShaderModule::static_shader_create_info_name_get(eShaderType shader_
     case POINTCLOUD_DEPTH_CONSERVATIVE:
       return "basic_depth_pointcloud_conservative";
     case COMPUTE_TEST:
-      return "bnpr_strokegen_test";
+      return "bnpr_strokegen_test_xxx";
 
     /* To avoid compiler warning about missing case. */
     case MAX_SHADER_TYPE:
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
index 4a33610836a..7b98d823540 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
@@ -23,67 +23,10 @@ namespace blender::bnpr {
 
 using namespace draw;
 
-constexpr eGPUSamplerState no_filter = GPU_SAMPLER_DEFAULT;
-constexpr eGPUSamplerState with_filter = GPU_SAMPLER_FILTER;
-
 #endif
 
 
 
-#define UBO_MIN_MAX_SUPPORTED_SIZE 1 << 14
-
-/* -------------------------------------------------------------------- */
-/** \name Debug Mode
- * \{ */
-
-/** These are just to make more sense of G.debug_value's values. Reserved range is 1-30. */
-enum eDebugMode : uint32_t {
-  DEBUG_NONE = 0u,
-  /**
-   * Gradient showing light evaluation hot-spots.
-   */
-  DEBUG_LIGHT_CULLING = 1u,
-  /**
-   * Show incorrectly downsample tiles in red.
-   */
-  DEBUG_HIZ_VALIDATION = 2u,
-  /**
-   * Tile-maps to screen. Is also present in other modes.
-   * - Black pixels, no pages allocated.
-   * - Green pixels, pages cached.
-   * - Red pixels, pages allocated.
-   */
-  DEBUG_SHADOW_TILEMAPS = 10u,
-  /**
-   * Random color per pages. Validates page density allocation and sampling.
-   */
-  DEBUG_SHADOW_PAGES = 11u,
-  /**
-   * Outputs random color per tile-map (or tile-map level). Validates tile-maps coverage.
-   * Black means not covered by any tile-maps LOD of the shadow.
-   */
-  DEBUG_SHADOW_LOD = 12u,
-  /**
-   * Outputs white pixels for pages allocated and black pixels for unused pages.
-   * This needs DEBUG_SHADOW_PAGE_ALLOCATION_ENABLED defined in order to work.
-   */
-  DEBUG_SHADOW_PAGE_ALLOCATION = 13u,
-  /**
-   * Outputs the tile-map atlas. Default tile-map is too big for the usual screen resolution.
-   * Try lowering SHADOW_TILEMAP_PER_ROW and SHADOW_MAX_TILEMAP before using this option.
-   */
-  DEBUG_SHADOW_TILE_ALLOCATION = 14u,
-  /**
-   * Visualize linear depth stored in the atlas regions of the active light.
-   * This way, one can check if the rendering, the copying and the shadow sampling functions works.
-   */
-  DEBUG_SHADOW_SHADOW_DEPTH = 15u
-};
-/** \} */
-
-
-
-
 #ifdef __cplusplus
 
 // Template to set buffer size in compile time
@@ -92,6 +35,5 @@ using StrokeGenTestBuf = draw::StorageArrayBuffer<uint, 4096, true>;
 
 }
 
-
 // namespace blender::bnpr
 #endif
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
index c821086ae5d..cf017d0823f 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
@@ -23,7 +23,7 @@ namespace blender::bnpr
     Instance &instance;
 
     /** Compute Resources */
-    StrokeGenTestBuf arr_buf_test_;
+    StrokeGenTestBuf strokegen_test_buf_;
 
 
   public:
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
index ec1d4f33f10..058198dac13 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
@@ -13,13 +13,13 @@ namespace blender::bnpr
 {
   using namespace blender;
 
-  void StrokeGenPassModule::dispatch_extract_mesh_contour(Object* ob)
+  void StrokeGenPassModule::rebuild_pass_extract_mesh_contour(Object* ob)
   {
     pass_comp_test.init();
     {
       auto& sub = pass_comp_test.sub("strokegen_comp_test_subpass");
       sub.shader_set(shaders_.static_shader_get(eShaderType::COMPUTE_TEST));
-      sub.bind_ssbo("buf_test", buffers_.arr_buf_test_);
+      sub.bind_ssbo("buf_test", buffers_.strokegen_test_buf_);
       sub.dispatch(int3(32, 1, 1));
       sub.barrier(GPU_BARRIER_SHADER_STORAGE);
     }
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
index edd4d92edfb..6663f38eec7 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
@@ -47,9 +47,21 @@ namespace blender::bnpr
     ~StrokeGenPassModule() {};
 
     /** Passes Batched by Usages */
-    void dispatch_extract_mesh_contour(Object* ob);
+    enum eType
+    {
+      EXTRACT_MESH_CONTOUR = 0
+    };
 
+    PassSimple& get_compute_pass(eType passType)
+    {
+      switch (passType) {
+        case EXTRACT_MESH_CONTOUR:
+          return pass_comp_test;
+      }
+      return pass_comp_test;
+    }
 
+    void rebuild_pass_extract_mesh_contour(Object* ob);
 
   };
 }
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
index 8c94eed402b..f350911e958 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
@@ -74,7 +74,7 @@ namespace blender::bnpr
     //  strokegen_passes.dispatch_extract_mesh_contour(ob);
     //  strokegen_passes.dispatch_XXX(...);
     //  ... ... ...
-    inst_.strokegen_passes.dispatch_extract_mesh_contour(ob);
+    inst_.strokegen_passes.rebuild_pass_extract_mesh_contour(ob);
 
 
   }
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
index 5d0304865db..964ee4114e3 100644
--- a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
@@ -1,55 +1,11 @@
 
 /**
- * Sort the lights by their Z distance to the camera.
- * Outputs ordered light buffer.
- * One thread processes one Light entity.
+* Testing compute shader for bnpr engine.
  */
 
 #pragma BLENDER_REQUIRE(gpu_shader_codegen_lib.glsl)
 
 void main()
 {
-  // uint src_index = gl_GlobalInvocationID.x;
-  // bool valid_thread = true;
-//
-  // if (src_index >= light_cull_buf.visible_count) {
-  //   /* Do not return because we use barriers later on (which need uniform control flow).
-  //    * Just process the same last item but avoid insertion. */
-  //   src_index = light_cull_buf.visible_count - 1;
-  //   valid_thread = false;
-  // }
-//
-  // float local_zdist = in_zdist_buf[src_index];
-//
-  // int prefix_sum = 0;
-  // /* Iterate over the whole key buffer. */
-  // uint iter = divide_ceil(light_cull_buf.visible_count, gl_WorkGroupSize.x);
-  // for (uint i = 0u; i < iter; i++) {
-  //   uint index = gl_WorkGroupSize.x * i + gl_LocalInvocationID.x;
-  //   /* NOTE: This will load duplicated values, but they will be discarded. */
-  //   index = min(index, light_cull_buf.visible_count - 1);
-  //   zdists_cache[gl_LocalInvocationID.x] = in_zdist_buf[index];
-//
-  //   barrier();
-//
-  //   /* Iterate over the cache line. */
-  //   uint line_end = min(gl_WorkGroupSize.x, light_cull_buf.visible_count - gl_WorkGroupSize.x * i);
-  //   for (uint j = 0u; j < line_end; j++) {
-  //     if (zdists_cache[j] < local_zdist) {
-  //       prefix_sum++;
-  //     }
-  //     else if (zdists_cache[j] == local_zdist) {
-  //       /* Same depth, use index to order and avoid same prefix for 2 different lights. */
-  //       if ((gl_WorkGroupSize.x * i + j) < src_index) {
-  //         prefix_sum++;
-  //       }
-  //     }
-  //   }
-  // }
-//
-  // if (valid_thread) {
-  //   /* Copy sorted light to render light buffer. */
-  //   uint input_index = in_key_buf[src_index];
-  //   out_light_buf[prefix_sum] = in_light_buf[input_index];
-  // }
+
 }
diff --git a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
index 0d1f735983d..bea2190c8d3 100644
--- a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
+++ b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
@@ -8,13 +8,16 @@
  * \{ */
 
 /* For details, see "gpu_shader_create_info.hh" */
-// GPU_SHADER_CREATE_INFO(bnpr_strokegen_test_comp)
+// GPU_SHADER_CREATE_INFO(bnpr_strokegen_test)
   // .do_static_compilation(true)
 
   /* -------------------------------------------------------------------- */
   /* Name of other infos to recursively merge with this one.
    * No data slot must overlap otherwise we throw an error. */
   // .additional_info("eevee_shared", "draw_view", "draw_view_culling")
+
+  /* -------------------------------------------------------------------- */
+  /* Macros */
   // .define("DOF_BOKEH_TEXTURE", "false")
 
   /* -------------------------------------------------------------------- */
@@ -55,11 +58,10 @@
 
 
 
-
 /* -------------------------------------------------------------------- */
 /** \test
  * \{ */
-GPU_SHADER_CREATE_INFO(bnpr_strokegen_test)
+GPU_SHADER_CREATE_INFO(bnpr_strokegen_test_xxx)
   .do_static_compilation(true)
   .storage_buf(0, Qualifier::READ_WRITE, "uint", "buf_test")
   .local_group_size(GROUP_SIZE_STROKEGEN_TEST) /* <== from "bnpr_defines.hh" */
-- 
2.38.1.windows.1


From 43d5a077e025f45380709d56e6802c5de72ad384 Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Sun, 8 Jan 2023 15:26:45 +0800
Subject: [PATCH 10/11] Testing scan & segscan

scan should be alright, however need to load with stride of vec4 when read scanned buffer with vec3 elements.

segscan not tested yet, there are some issue with shader_builder, which fucks up with the incremental build. I'll commit for now and rebase to master.
---
 source/blender/draw/CMakeLists.txt            |   4 +
 .../blender/draw/engines/bnpr/bnpr_defines.hh |  21 +-
 .../blender/draw/engines/bnpr/bnpr_engine.cc  |  15 +-
 .../draw/engines/bnpr/bnpr_instance.cc        |  19 +-
 .../draw/engines/bnpr/bnpr_instance.hh        |   5 +-
 .../blender/draw/engines/bnpr/bnpr_shader.cc  |  12 +
 .../blender/draw/engines/bnpr/bnpr_shader.hh  |   8 +
 .../draw/engines/bnpr/bnpr_shader_shared.hh   | 114 +++-
 .../bnpr/bnpr_strokegen_buffer_pool.cc        |  25 +-
 .../bnpr/bnpr_strokegen_buffer_pool.hh        |  14 +-
 .../draw/engines/bnpr/bnpr_strokegen_pass.cc  |  90 ++-
 .../draw/engines/bnpr/bnpr_strokegen_pass.hh  | 121 +++-
 source/blender/draw/engines/bnpr/bnpr_sync.cc |   4 +-
 .../bnpr/shaders/bnpr_hlsl_support_lib.glsl   |   8 +
 .../bnpr_scan_no_subgroup_codegen_lib.glsl    |  69 +++
 .../shaders/bnpr_scan_no_subgroup_lib.glsl    | 576 ++++++++++++++++++
 .../bnpr/shaders/bnpr_scan_test_comp.glsl     | 279 +++++++++
 .../shaders/bnpr_strokegen_test_comp.glsl     |   2 +-
 .../bnpr/shaders/infos/bnpr_test_info.hh      | 127 +++-
 19 files changed, 1476 insertions(+), 37 deletions(-)
 create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl
 create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl
 create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl
 create mode 100644 source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl

diff --git a/source/blender/draw/CMakeLists.txt b/source/blender/draw/CMakeLists.txt
index e6885e1958d..a9d28e25192 100644
--- a/source/blender/draw/CMakeLists.txt
+++ b/source/blender/draw/CMakeLists.txt
@@ -704,7 +704,11 @@ set(GLSL_SRC
   engines/image/shaders/image_engine_depth_frag.glsl
   engines/image/shaders/image_engine_depth_vert.glsl
 
+  engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl
+  engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl
+  engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl
   engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+  engines/bnpr/shaders/bnpr_scan_test_comp.glsl
 
   engines/bnpr/bnpr_defines.hh
   engines/bnpr/bnpr_shader_shared.hh
diff --git a/source/blender/draw/engines/bnpr/bnpr_defines.hh b/source/blender/draw/engines/bnpr/bnpr_defines.hh
index 1ffca605ca9..4cc48d0ddd0 100644
--- a/source/blender/draw/engines/bnpr/bnpr_defines.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_defines.hh
@@ -11,5 +11,24 @@
 
 #pragma once
 
+#define GROUP_SIZE_STROKEGEN_TEST 512u
+#define GROUP_SIZE_BNPR_SCAN_TEST_SWEEP 1024u
+#define GROUP_SIZE_BNPR_SCAN_TEST_AGGRG 1024u
+
+#define NUM_ITEMS_BNPR_SCAN_TEST 1973581u
+
+
+#ifndef GPU_SHADER
+# define BNPR_SCAN_TEST_DATA_TYPE uint4
+# define BNPR_SCAN_TEST_DATA_TYPE_STR "uvec3"
+
+// remember to update SSBOData_SegScanTest if this changes
+# define BNPR_SEG_SCAN_TEST_STRUCT_TYPE SSBOData_SegScanTest
+# define BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR "SSBOData_SegScanTest"
+#endif
+
+
+
+
+
 
-#define GROUP_SIZE_STROKEGEN_TEST 512
diff --git a/source/blender/draw/engines/bnpr/bnpr_engine.cc b/source/blender/draw/engines/bnpr/bnpr_engine.cc
index 0e123f6e50c..aa4c039f772 100644
--- a/source/blender/draw/engines/bnpr/bnpr_engine.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_engine.cc
@@ -21,6 +21,7 @@
 
 #include "bnpr_instance.hh"
 #include "bnpr_shader.hh"
+#include "intern/mallocn_intern.h"
 
 
 using namespace blender;
@@ -131,22 +132,20 @@ static void bnpr_draw_scene(void *vedata)
 
 
   // TODO: not sure which is better, frame-buffer or texture list?
-  // DefaultFramebufferList *dfbl = DRW_viewport_framebuffer_list_get();
-  DefaultTextureList *dtxl = DRW_viewport_texture_list_get();
+  DefaultFramebufferList *dfbl = DRW_viewport_framebuffer_list_get();
+  // DefaultTextureList *dtxl = DRW_viewport_texture_list_get();
 
   const DRWView *default_view = DRW_view_default_get();
+  const DRWView *active_view = DRW_view_get_active();
   draw::Manager *manager = DRW_manager_get();
   draw::View view("DefaultView", default_view);
+
   // draw passes
-  ved->instance->draw_viewport(*manager, view, dtxl->depth, dtxl->color);
+  ved->instance->draw_viewport(*manager, view);
   // display error msg at the top of the render viewport
   STRNCPY(ved->info, ved->instance->info.c_str());
 
 
-
-  bnpr_draw_scene_legacy(vedata);
-
-
   /* Reset view for other following engines. */
   DRW_view_set_active(nullptr);
 }
@@ -384,7 +383,7 @@ static void bnpr_engine_free(void)
 
 static void bnpr_render_to_image(void *vedata, struct RenderEngine *engine,
                                     struct RenderLayer *layer,
-                                    const struct rcti *UNUSED(rect)) {
+                                    const struct rcti *rect) {
   UNUSED_VARS(vedata, engine, layer);
 }
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.cc b/source/blender/draw/engines/bnpr/bnpr_instance.cc
index 46be7fd8d31..ecc7d8b9cf5 100644
--- a/source/blender/draw/engines/bnpr/bnpr_instance.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.cc
@@ -20,6 +20,7 @@
 #include "RE_pipeline.h"
 
 #include "bnpr_instance.hh"
+#include "bnpr_defines.hh"
 
 namespace blender::bnpr
 {
@@ -51,6 +52,7 @@ namespace blender::bnpr
     camera_orig_object = camera_object_;
 
     info = "";
+    frame_counter = 0;
   }
 
   void Instance::update_eval_members()
@@ -78,6 +80,8 @@ namespace blender::bnpr
   void Instance::begin_sync(Manager& manager)
   {
     /* Init draw passes and manager related stuff. (Begin render graph) */
+    strokegen_buffers.sync();
+    strokegen_passes.sync();
   }
 
   void Instance::end_sync(Manager&)
@@ -132,11 +136,20 @@ namespace blender::bnpr
   /** \name Rendering
    * \{ */
 
-  void Instance::draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
-    GPUTexture* color_tx)
+  void Instance::draw_viewport(Manager& manager, View& view)
   {
     /* Submit passes here. (Execute render graph) */
-    manager.submit(strokegen_passes.get_compute_pass(StrokeGenPassModule::eType::EXTRACT_MESH_CONTOUR), view);
+    // manager.submit(strokegen_passes.get_compute_pass(StrokeGenPassModule::eType::SCAN_TEST), view);
+    manager.submit(strokegen_passes.get_compute_pass(StrokeGenPassModule::eType::SEGSCAN_TEST), view);
+
+    if (frame_counter % 32 == 0)
+    {
+      // strokegen_passes.validate_pass_scan_test<BNPR_SCAN_TEST_DATA_TYPE>(
+      //   [](const BNPR_SCAN_TEST_DATA_TYPE& a, const BNPR_SCAN_TEST_DATA_TYPE& b) {return a == b;}
+      // );
+    }
+    frame_counter = (frame_counter + 1) % 100000000;
+
   }
 
   /** \} */
diff --git a/source/blender/draw/engines/bnpr/bnpr_instance.hh b/source/blender/draw/engines/bnpr/bnpr_instance.hh
index 6d7532c8ea3..af5be3f88a8 100644
--- a/source/blender/draw/engines/bnpr/bnpr_instance.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_instance.hh
@@ -60,10 +60,12 @@ namespace blender::bnpr
 
 
 
+
     /** Info string displayed at the top of the render / viewport. */
     std::string info = "";
     /** Debug mode from debug value. */
     // eDebugMode debug_mode = eDebugMode::DEBUG_NONE;
+    uint frame_counter; // for debugging
 
 
 
@@ -87,8 +89,7 @@ namespace blender::bnpr
     void object_sync(Manager& manager, ObjectRef& object_ref);
 
 
-    void draw_viewport(Manager& manager, View& view, GPUTexture* depth_tx,
-                       GPUTexture* color_tx);
+    void draw_viewport(Manager& manager, View& view);
 
 
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.cc b/source/blender/draw/engines/bnpr/bnpr_shader.cc
index c77bc4675fa..ff636462f65 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_shader.cc
@@ -92,6 +92,18 @@ const char *ShaderModule::static_shader_create_info_name_get(eShaderType shader_
       return "basic_depth_pointcloud_conservative";
     case COMPUTE_TEST:
       return "bnpr_strokegen_test_xxx";
+    case SCAN_TEST_UPSWEEP:
+      return "bnpr_scan_test_upsweep";
+    case SCAN_TEST_AGGREGATE:
+      return "bnpr_scan_test_aggregate";
+    case SCAN_TEST_DWSWEEP:
+      return "bnpr_scan_test_dwsweep";
+    case SEGSCAN_TEST_UPSWEEP:
+      return "bnpr_segscan_test_upsweep";
+    case SEGSCAN_TEST_AGGREGATE:
+      return "bnpr_segscan_test_aggregate";
+    case SEGSCAN_TEST_DWSWEEP:
+      return "bnpr_segscan_test_dwsweep";
 
     /* To avoid compiler warning about missing case. */
     case MAX_SHADER_TYPE:
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader.hh b/source/blender/draw/engines/bnpr/bnpr_shader.hh
index ff758760c22..00e3e09625d 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader.hh
@@ -31,6 +31,14 @@ enum eShaderType {
   DEPTH_CONSERVATIVE,
   POINTCLOUD_DEPTH_CONSERVATIVE,
 
+  SCAN_TEST_UPSWEEP,
+  SCAN_TEST_AGGREGATE,
+  SCAN_TEST_DWSWEEP,
+
+  SEGSCAN_TEST_UPSWEEP,
+  SEGSCAN_TEST_AGGREGATE,
+  SEGSCAN_TEST_DWSWEEP,
+
   MAX_SHADER_TYPE,
 };
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
index 7b98d823540..b7e0c17e628 100644
--- a/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_shader_shared.hh
@@ -26,12 +26,122 @@ using namespace draw;
 #endif
 
 
+  static inline uint wang_hash(uint seed)
+  {
+    seed = (seed ^ 61) ^ (seed >> 16);
+    seed *= 9;
+    seed = seed ^ (seed >> 4);
+    seed *= 0x27d4eb2d;
+    seed = seed ^ (seed >> 15);
+    return seed;
+  }
+
+
+  static inline uint compute_num_threads(
+    uint numWorkItems,
+    uint numItemsPerThread = 1u, uint numThreadsPerItem = 1u
+  )
+  {
+    uint numThreads = numWorkItems;
+
+    if (numItemsPerThread != 1u)
+      numThreads = ((numWorkItems + numItemsPerThread - 1u) / numItemsPerThread);
+    else if (numThreadsPerItem != 1u)
+      numThreads = numThreadsPerItem * numWorkItems;
+
+    return numThreads;
+  }
+
+  static inline uint compute_num_groups(
+    uint numWorkItems, uint groupSize,
+    uint numItemsPerThread = 1u, uint numThreadsPerItem = 1u
+  )
+  {
+    const uint numThreads = compute_num_threads(
+      numWorkItems, numItemsPerThread,
+      numThreadsPerItem
+    );
+
+#if !defined(GPU_SHADER)
+    return math::max(1u, ((numThreads + groupSize - 1) / groupSize));
+#else
+      return max(1u, ((numThreads + groupSize - 1) / groupSize));
+#endif
+  }
+
+  static inline uint tree_seg_scan_encode_upsweep_hfs(uint hf_partialSum, uint hf_orig)
+  {
+    return ((hf_orig << 1) | hf_partialSum);
+  }
+
+  static inline void tree_seg_scan_decode_upsweep_hfs(
+#if !defined(GPU_SHADER)
+    uint hfs_encoded, uint& out_hf_orig, uint& out_hf_partialSum
+#else
+    uint hfs_encoded, out uint out_hf_orig, out uint out_hf_partialSum
+#endif
+  )
+  {
+    out_hf_partialSum = (hfs_encoded & 1);
+    hfs_encoded >>= 1;
+    out_hf_orig = (hfs_encoded & 1);
+  }
+
+  static inline uint tree_seg_scan_decode_upsweep_hfs_get_origHF(
+#if !defined(GPU_SHADER)
+    uint hfs_encoded
+#else
+    uint hfs_encoded
+#endif
+  )
+  {
+    hfs_encoded >>= 1;
+    return (hfs_encoded & 1);
+  }
+
+  static inline uint tree_seg_scan_decode_upsweep_hfs_get_sumHF(
+#if !defined(GPU_SHADER)
+    uint hfs_encoded
+#else
+    uint hfs_encoded
+#endif
+  )
+  {
+    return (hfs_encoded & 1);
+  }
+
+
+
+
+  struct UBData_TreeScan
+  {
+    uint num_scan_items;
+    uint num_valid_scan_threads;
+    uint num_thread_groups;
+    uint dummy;
+  };
+  BLI_STATIC_ASSERT_ALIGN(UBData_TreeScan, 16)
+
+  struct SSBOData_SegScanTest
+  {
+    uint hf;
+#ifndef GPU_SHADER
+    uint3 val;
+#else
+    uvec3 val;
+#endif
+  };
+  // BLI_STATIC_ASSERT_ALIGN(SSBOData_SegScanTest, 16)
+
+
 
 #ifdef __cplusplus
 
 // Template to set buffer size in compile time
-using StrokeGenTestBuf = draw::StorageArrayBuffer<uint, 4096, true>;
-
+using SSBO_StrokeGenTest = draw::StorageArrayBuffer<uint, 4096 * 4, true>;
+using SSBO_BnprScanData = draw::StorageArrayBuffer<uint, 2048 * 2048 * 2, true>;
+using SSBO_BnprScanAggregates = draw::StorageArrayBuffer<uint, 512 * 16, true>;
+using UBO_BnprTreeScan = draw::UniformBuffer<UBData_TreeScan>;
 
 }
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
index 39d96265894..76736b9be11 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.cc
@@ -8,11 +8,34 @@
 
 #include "bnpr_strokegen_buffer_pool.hh"
 #include "bnpr_instance.hh"
+#include "bnpr_defines.hh"
 
 namespace blender::bnpr
 {
-  void GPUBufferPoolModule::sync(Object* object)
+  void GPUBufferPoolModule::sync()
   {
+    UBO_BnprTreeScan& ubo_tree_scan = ubo_bnpr_tree_scan_infos_;
+    {
+      ubo_tree_scan.num_scan_items = NUM_ITEMS_BNPR_SCAN_TEST;
+      ubo_tree_scan.num_valid_scan_threads = compute_num_threads(
+        NUM_ITEMS_BNPR_SCAN_TEST,
+        2u
+      );
+      ubo_tree_scan.num_thread_groups = compute_num_groups(
+        NUM_ITEMS_BNPR_SCAN_TEST,
+        GROUP_SIZE_BNPR_SCAN_TEST_SWEEP,
+        2u
+      );
+      ubo_tree_scan.dummy = 0u;
+    }
+    ubo_bnpr_tree_scan_infos_.push_update();
+
+
+  }
+
+  void GPUBufferPoolModule::sync_object(Object* ob)
+  {
+
   }
 
   void GPUBufferPoolModule::end_sync()
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
index cf017d0823f..c4f145aa3e1 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_buffer_pool.hh
@@ -23,14 +23,20 @@ namespace blender::bnpr
     Instance &instance;
 
     /** Compute Resources */
-    StrokeGenTestBuf strokegen_test_buf_;
+    SSBO_StrokeGenTest ssbo_bnpr_test_;
 
+    SSBO_BnprScanData ssbo_bnpr_in_scan_data_;
+    SSBO_BnprScanData ssbo_bnpr_out_scan_data_;
+    SSBO_BnprScanAggregates ssbo_bnpr_scan_block_sum_;
+
+    UBO_BnprTreeScan ubo_bnpr_tree_scan_infos_;
 
   public:
-    GPUBufferPoolModule(Instance &inst) : instance(inst) {};
-    ~GPUBufferPoolModule() {};
+    GPUBufferPoolModule(Instance &inst) : instance(inst) {}
+    ~GPUBufferPoolModule() {}
 
-    void sync(Object* object);
+    void sync();
+    void sync_object(Object* ob);
     void end_sync();
 
   };
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
index 058198dac13..e302d2672dc 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.cc
@@ -13,18 +13,94 @@ namespace blender::bnpr
 {
   using namespace blender;
 
-  void StrokeGenPassModule::rebuild_pass_extract_mesh_contour(Object* ob)
+  void StrokeGenPassModule::sync()
   {
-    pass_comp_test.init();
-    {
-      auto& sub = pass_comp_test.sub("strokegen_comp_test_subpass");
-      sub.shader_set(shaders_.static_shader_get(eShaderType::COMPUTE_TEST));
-      sub.bind_ssbo("buf_test", buffers_.strokegen_test_buf_);
-      sub.dispatch(int3(32, 1, 1));
+    rebuild_pass_scan_test();
+    rebuild_pass_segscan_test();
+  }
+
+  void StrokeGenPassModule::rebuild_pass_extract_mesh_contour(Object* ob, GPUBatch* gpu_batch)
+  {
+
+  }
+
+  void StrokeGenPassModule::rebuild_pass_scan_test()
+  {
+    pass_scan_test.init();
+    { // upsweep for tree-scan
+      auto& sub = pass_scan_test.sub("strokegen_scan_test_upsweep");
+      sub.shader_set(shaders_.static_shader_get(eShaderType::SCAN_TEST_UPSWEEP));
+
+      // Note: keep the same slot binding as in shader_create_info
+      sub.bind_ssbo(0, buffers_.ssbo_bnpr_in_scan_data_);
+      sub.bind_ssbo(1, buffers_.ssbo_bnpr_out_scan_data_);
+      sub.bind_ssbo(2, buffers_.ssbo_bnpr_scan_block_sum_);
+      sub.bind_ubo(0, buffers_.ubo_bnpr_tree_scan_infos_);
+
+      sub.dispatch(int3(buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups, 1, 1));
+      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+    }
+    { // reduction for tree-scan
+      auto& sub = pass_scan_test.sub("strokegen_scan_test_aggregate");
+      sub.shader_set(shaders_.static_shader_get(eShaderType::SCAN_TEST_AGGREGATE));
+
+      // Note: keep the same slot binding as in shader_create_info
+      sub.bind_ssbo(0, buffers_.ssbo_bnpr_scan_block_sum_);
+
+      sub.dispatch(int3(1, 1, 1));
+      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+    }
+    { // down sweep for tree-scan
+      auto& sub = pass_scan_test.sub("strokegen_scan_test_dwsweep");
+      sub.shader_set(shaders_.static_shader_get(eShaderType::SCAN_TEST_DWSWEEP));
+
+      // Note: keep the same slot binding as in shader_create_info
+      sub.bind_ssbo(0, buffers_.ssbo_bnpr_out_scan_data_);
+      sub.bind_ssbo(1, buffers_.ssbo_bnpr_scan_block_sum_);
+      sub.bind_ubo(0, buffers_.ubo_bnpr_tree_scan_infos_);
+
+      sub.dispatch(int3(buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups, 1, 1));
       sub.barrier(GPU_BARRIER_SHADER_STORAGE);
     }
   }
 
+  void StrokeGenPassModule::rebuild_pass_segscan_test()
+  {
+    pass_segscan_test.init();
+    { // upsweep for tree-scan
+      auto& sub = pass_segscan_test.sub("strokegen_segscan_test_upsweep");
+      sub.shader_set(shaders_.static_shader_get(SEGSCAN_TEST_UPSWEEP));
+
+      // Note: keep the same slot binding as in shader_create_info
+      sub.bind_ssbo(0, buffers_.ssbo_bnpr_in_scan_data_);
+      sub.bind_ssbo(1, buffers_.ssbo_bnpr_out_scan_data_);
+      sub.bind_ssbo(2, buffers_.ssbo_bnpr_scan_block_sum_);
+      sub.bind_ubo(0, buffers_.ubo_bnpr_tree_scan_infos_);
+
+      sub.dispatch(int3(buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups, 1, 1));
+      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+    }
+    { // reduction for tree-scan
+      auto& sub = pass_segscan_test.sub("strokegen_segscan_test_aggregate");
+      sub.shader_set(shaders_.static_shader_get(SEGSCAN_TEST_AGGREGATE));
+
+      // Note: keep the same slot binding as in shader_create_info
+      sub.bind_ssbo(0, buffers_.ssbo_bnpr_scan_block_sum_);
+
+      sub.dispatch(int3(1, 1, 1));
+      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+    }
+    { // down sweep for tree-scan
+      auto& sub = pass_segscan_test.sub("strokegen_segscan_test_dwsweep");
+      sub.shader_set(shaders_.static_shader_get(SEGSCAN_TEST_DWSWEEP));
 
+      // Note: keep the same slot binding as in shader_create_info
+      sub.bind_ssbo(0, buffers_.ssbo_bnpr_out_scan_data_);
+      sub.bind_ssbo(1, buffers_.ssbo_bnpr_scan_block_sum_);
+      sub.bind_ubo(0, buffers_.ubo_bnpr_tree_scan_infos_);
 
+      sub.dispatch(int3(buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups, 1, 1));
+      sub.barrier(GPU_BARRIER_SHADER_STORAGE);
+    }
+  }
 }
diff --git a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
index 6663f38eec7..b2904d012df 100644
--- a/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_strokegen_pass.hh
@@ -26,6 +26,8 @@ namespace blender::bnpr
   private:
     /** Compute Passes */
     draw::PassSimple pass_comp_test = {"Strokegen Compute Test"};
+    draw::PassSimple pass_scan_test = {"Bnpr GPU Blelloch Scan Test"};
+    draw::PassSimple pass_segscan_test = {"Bnpr GPU Blelloch SegScan Test"};
 
     /** Instance */
     ShaderModule &shaders_;
@@ -49,20 +51,131 @@ namespace blender::bnpr
     /** Passes Batched by Usages */
     enum eType
     {
-      EXTRACT_MESH_CONTOUR = 0
+      SCAN_TEST = 0,
+      SEGSCAN_TEST
     };
 
     PassSimple& get_compute_pass(eType passType)
     {
       switch (passType) {
-        case EXTRACT_MESH_CONTOUR:
-          return pass_comp_test;
+        case SCAN_TEST:
+          return pass_scan_test;
+        case SEGSCAN_TEST:
+          return pass_segscan_test;
       }
       return pass_comp_test;
     }
 
-    void rebuild_pass_extract_mesh_contour(Object* ob);
+    void sync();
+    void rebuild_pass_extract_mesh_contour(Object* ob, GPUBatch* gpu_batch);
+    void rebuild_pass_scan_test();
+    void rebuild_pass_segscan_test();
+
+
+    template<typename T>
+    void validate_pass_scan_test(bool (*equals)(const T&, const T&));
+
+    template<typename T>
+    bool validate_inter_block_exclusive_scan(
+      const T* bufferInputVals, const T* bufferPrefixSum,
+      bool (*equals)(const T&, const T&),
+      uint num_scan_items, uint blk_size, uint numBlocks
+    );
+    template<typename T>
+    bool validate_exclusive_scan(
+      const T* bufferInputVals, const T* bufferPrefixSum,
+      bool (*equals)(const T&, const T&),
+      uint num_scan_items
+    );
+
 
   };
+
+
+
+  template <typename T>
+  void StrokeGenPassModule::validate_pass_scan_test(bool (*equals)(const T&, const T&))
+  {
+    SSBO_BnprScanData& buf_scan_inputs = buffers_.ssbo_bnpr_in_scan_data_;
+    buf_scan_inputs.read();
+    T* data_scan_inputs = reinterpret_cast<T*>(buf_scan_inputs.data());
+
+    SSBO_BnprScanData& buf_scan_output = buffers_.ssbo_bnpr_out_scan_data_;
+    buf_scan_output.read();
+    T* data_scan_output = reinterpret_cast<T*>(buf_scan_output.data());
+
+    bool valid_inter_block_scan = StrokeGenPassModule::validate_inter_block_exclusive_scan<T>(
+      data_scan_inputs, data_scan_output,
+      equals,
+      buffers_.ubo_bnpr_tree_scan_infos_.num_scan_items,
+      GROUP_SIZE_BNPR_SCAN_TEST_SWEEP * 2u,
+      buffers_.ubo_bnpr_tree_scan_infos_.num_thread_groups
+    );
+    if (!valid_inter_block_scan)
+      fprintf(stderr, "bnpr: error: INTER-BLOCK scan test failed");
+
+    bool valid_global_scan = StrokeGenPassModule::validate_exclusive_scan<T>(
+      data_scan_inputs, data_scan_output,
+      equals,
+      buffers_.ubo_bnpr_tree_scan_infos_.num_scan_items
+    );
+    if (!valid_global_scan)
+      fprintf(stderr, "bnpr: error: GLOBAL scan test failed");
+  }
+
+
+  template <typename T>
+  bool StrokeGenPassModule::validate_inter_block_exclusive_scan(
+    const T* const bufferInputVals, const T* const bufferPrefixSum,
+    bool (*equals)(const T&, const T&),
+    uint num_scan_items, uint blk_size, uint numBlocks
+  )
+  {
+    Vector<int> failedElems(0);
+
+    for (uint blk_id = 0u; blk_id < numBlocks; blk_id++)
+    {
+      for (uint blk_offset = 0u; blk_offset < blk_size - 1u; blk_offset++)
+      {
+        // index might go out of bound
+        uint index = blk_id * blk_size + blk_offset;
+        if (index >= num_scan_items - 2u)
+          break;
+
+        if (false == equals(
+          bufferPrefixSum[index] + bufferInputVals[index],
+          bufferPrefixSum[index + 1]
+        ))
+        {
+          failedElems.append(index);
+        }
+      }
+    }
+
+    if (!failedElems.is_empty())
+    {
+      return false;
+    }
+
+    return true;
+  }
+
+
+  template <typename T>
+  bool StrokeGenPassModule::validate_exclusive_scan(const T* bufferInputVals,
+                                                    const T* bufferPrefixSum,
+                                                    bool (* equals)(const T&, const T&),
+                                                    uint num_scan_items)
+  {
+    return validate_inter_block_exclusive_scan(
+      bufferInputVals, bufferPrefixSum,
+      equals,
+      num_scan_items,
+      num_scan_items,
+      1
+    );
+  }
+
+
 }
 
diff --git a/source/blender/draw/engines/bnpr/bnpr_sync.cc b/source/blender/draw/engines/bnpr/bnpr_sync.cc
index f350911e958..cd708ab9fb2 100644
--- a/source/blender/draw/engines/bnpr/bnpr_sync.cc
+++ b/source/blender/draw/engines/bnpr/bnpr_sync.cc
@@ -64,6 +64,7 @@ namespace blender::bnpr
     GPUBatch *geobatch = DRW_cache_object_edge_detection_get(ob, &mesh_is_manifold);
 
     if (geobatch == nullptr) return;
+    if (geobatch->elem == nullptr) return;
 
     // Old way to do this:
     // See "draw_subdiv_build_tris_buffer"
@@ -74,7 +75,8 @@ namespace blender::bnpr
     //  strokegen_passes.dispatch_extract_mesh_contour(ob);
     //  strokegen_passes.dispatch_XXX(...);
     //  ... ... ...
-    inst_.strokegen_passes.rebuild_pass_extract_mesh_contour(ob);
+    inst_.strokegen_passes.rebuild_pass_extract_mesh_contour(ob, geobatch);
+
 
 
   }
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl
new file mode 100644
index 00000000000..6a8328140c5
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_hlsl_support_lib.glsl
@@ -0,0 +1,8 @@
+#ifndef BNPR_HLSL_SUPPORT_INCLUDED
+#define BNPR_HLSL_SUPPORT_INCLUDED
+
+// translate bit stream(s)
+#define asuint(x) floatBitsToUint(x)
+#define asfloat(x) uintBitsToFloat(x)
+
+#endif
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl
new file mode 100644
index 00000000000..d1d65d6364e
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_codegen_lib.glsl
@@ -0,0 +1,69 @@
+#ifndef BNPR_SCAN_NO_SUBGROUP_CODEGEN_LIB
+#define BNPR_SCAN_NO_SUBGROUP_CODEGEN_LIB
+
+#pragma BLENDER_REQUIRE(bnpr_scan_no_subgroup_lib.glsl)
+
+/* -------------------------------------------------------------------- */
+/** \name Tree Scan LDS Cache
+ * \{ */
+DECLARE_TREE_SCAN_CACHE
+
+#ifdef IS_TREE_SEG_SCAN
+
+	DECLARE_TREE_SCAN_CACHE_HF
+
+#endif
+/** \} */
+
+
+
+/* -------------------------------------------------------------------- */
+/** \name Utility Functions
+ * \{ */
+DECLARE_TREE_SCAN_INDEXING_FUNCTION
+
+DECLARE_TREE_SCAN_FUNC_CLEAN_SCAN_DATA
+
+DECLARE_TREE_SCAN_FUNC_CLEAN_SEG_SCAN_DATA
+
+/** \} */
+
+
+
+
+#ifndef IS_TREE_SEG_SCAN
+/* -------------------------------------------------------------------- */
+/** \name Scan Functions
+ * \{ */
+DECLARE_TREE_SCAN_FUNC_BLOCK
+
+DECLARE_TREE_SCAN_FUNC_AGGREGATE
+
+/** \} */
+#endif
+
+
+
+
+
+#ifdef IS_TREE_SEG_SCAN
+/* -------------------------------------------------------------------- */
+/** \name Segmented Tree Scan Functions
+ * \{ */
+
+DECLARE_TREE_SEGSCAN_FUNC_DWSWEEP_FILL_CACHE
+
+DECLARE_TREE_SEGSCAN_FUNC_AGGREGATE_FILL_CACHE
+
+DECLARE_TREE_SEGSCAN_FUNC_UPSWEEP
+
+DECLARE_TREE_SEGSCAN_FUNC_DWSWEEP
+
+/** \} */
+#endif
+
+
+
+
+
+#endif
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl
new file mode 100644
index 00000000000..aaaecd11e34
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_no_subgroup_lib.glsl
@@ -0,0 +1,576 @@
+#pragma BLENDER_REQUIRE(bnpr_hlsl_support_lib.glsl)
+
+#ifndef BNPR_SCAN_NO_SUBGROUP_INCLUDED
+#define BNPR_SCAN_NO_SUBGROUP_INCLUDED
+
+/* Scan Operators */
+uint u32_add(uint a, uint b)
+{
+	return a + b;
+}
+uvec2 uvec2_add(uvec2 a, uvec2 b)
+{
+	return a + b;
+}
+uvec3 uvec3_add(uvec3 a, uvec3 b)
+{
+	return a + b;
+}
+uvec4 uvec4_add(uvec4 a, uvec4 b)
+{
+	return a + b;
+}
+float f32_add(float a, float b)
+{
+	return a + b;
+}
+
+
+
+
+
+/* Inputs ---------------------                                                       */
+/* Example:                                                                           */
+/* (- basic -)                                                                        */
+/* #define SCAN_DATA_TYPE uvec2			    // Input data type for scan operation        */
+/* #define SCAN_OP(a, b) (a + b)				  // Scan operation                            */
+/* #define SCAN_ZERO_VAL                // Zero value for scan operator               */
+/* #define SCAN_BLOCK_SIZE 256			      // Typically thread_group_size               */
+/* #define SCAN_FUNCTION_TAG ScanTest   // Alias name for this set of scan ops        */
+/* ---------------------------------------                                            */
+
+
+/* Macro expansion, for details, see
+/* ---------------------------------------
+/* https://stackoverflow.com/questions/1489932/how-to-concatenate-twice-with-the-c-preprocessor-and-expand-a-macro-as-in-arg */
+#define CAT(x, y) CAT_(x, y)
+#define CAT_(x, y) x ## y
+
+
+/* Type & Type conversion & Scan OP
+/* --------------------------------------- */
+#define T SCAN_DATA_TYPE
+#define tag SCAN_FUNCTION_TAG
+#define OP SCAN_OP
+
+
+/* thread group size provided in glsl
+/* --------------------------------------- */
+#ifdef SCAN_BLOCK_SIZE
+# undef SCAN_BLOCK_SIZE
+#endif
+#define SCAN_BLOCK_SIZE ((gl_WorkGroupSize.x))
+
+#define DATA_SIZE       ((2u * SCAN_BLOCK_SIZE))
+
+
+/* Padding Macros for Eliminating Bank Conflicts
+/* --------------------------------------------------------- */
+#define NUM_BANKS       32
+#define LOG_NUM_BANKS   5
+#define OFFSET_BANK_CONFLICT_FREE(x) (((x) >> LOG_NUM_BANKS))
+
+
+// Tree Scan LDS Caches
+// ------------------------------------------------------------
+#define TREE_SCAN_CACHE CAT(TreeScanCache, tag)
+#define TREE_SCAN_CACHE_SIZE (DATA_SIZE + DATA_SIZE / NUM_BANKS)
+#define TREE_SCAN_CACHE_HF CAT(TreeScanCacheHF, tag)
+
+
+#define DECLARE_TREE_SCAN_CACHE \
+	shared T TREE_SCAN_CACHE[TREE_SCAN_CACHE_SIZE]; \
+
+#define DECLARE_TREE_SCAN_CACHE_HF \
+	shared uint TREE_SCAN_CACHE_HF[TREE_SCAN_CACHE_SIZE]; \
+
+
+
+// Tree Scan
+// ------------------------------------------------------------
+struct TreeScanIndices
+{
+  uvec2 global_x2; /* index of element in global compute buffer */
+  uvec2 lds_x2;    /* index of element 0/1 in shared memory */
+};
+
+/**
+ * \brief Returns (Global_scanAddr0, Global_scanAddr1, LDS_scanAddr0, LDS_scanAddr1)
+ *			LDS_scanAddr0/1 : index of element 0/1 in shared memory
+ *			Global_scanAddr0/1 : index of element in global compute buffer
+ */
+#define DECLARE_TREE_SCAN_INDEXING_FUNCTION                                                             \
+TreeScanIndices GetTreeScanIndices(					                                                        \
+	uint groupIdx, uint gIdx					                                                              \
+){  																				                                         \
+	const uint groupOffset = (DATA_SIZE) * gIdx.x;									                             \
+                                                                                                        \
+	uint ai = groupIdx;                /*   0   1   2   3 ... 255  => ai	*/	                          \
+	/* ------ + 1 * 512 ------- (Suppose gIdx.x == 1)						*/		                          \
+	uint scanAddrA = groupOffset + ai; /* 512 513 514 515 ... 767  => scanAddrA	*/	                    \
+                                                                                                        \
+	uint bi = ai + DATA_SIZE / 2; /* 256 257 258 259 ... 511   => bi			*/	                          \
+	uint scanAddrB = groupOffset + bi; /* 768 641 642 643 ... 1151  => scanAddrB*/	                    \
+                                                                                                        \
+	return TreeScanIndices(uvec2(scanAddrA, scanAddrB), uvec2(ai, bi));						                 \
+}                                                                                                       \
+
+
+#define _FUNC_CLEAN_SCAN_DATA CAT(TreeScanCleanData, tag)
+/**
+ * \brief Clear item that not mapped to actual scanned data
+ */
+#define DECLARE_TREE_SCAN_FUNC_CLEAN_SCAN_DATA \
+void _FUNC_CLEAN_SCAN_DATA( \
+    TreeScanIndices scan_ids,       \
+    uint num_scanned_items,         \
+    inout T scan_data_A,            \
+    inout T scan_data_B             \
+){ \
+  if (scan_ids.global_x2.x >= num_scanned_items)        \
+    scan_data_A = SCAN_ZERO_VAL;                        \
+  if (scan_ids.global_x2.y >= num_scanned_items)        \
+    scan_data_B = SCAN_ZERO_VAL;                        \
+} \
+
+
+#define _FUNC_CLEAN_SEG_SCAN_DATA CAT(TreeScanCleanData, tag)
+/**
+ * \brief Clear item that not mapped to actual scanned data
+ */
+#define DECLARE_TREE_SCAN_FUNC_CLEAN_SEG_SCAN_DATA \
+void _FUNC_CLEAN_SEG_SCAN_DATA( \
+	TreeScanIndices scan_ids,       \
+	uint num_scanned_items,         \
+	inout uint hf_A,                \
+	inout T scan_data_A,            \
+	inout uint hf_B,                \
+	inout T scan_data_B             \
+){ \
+	if (scan_ids.global_x2.x >= num_scanned_items)        \
+	{ \
+		scan_data_A = SCAN_ZERO_VAL;                       \
+		hf_A = 1u;                                         \
+	} \
+	if (scan_ids.global_x2.y >= num_scanned_items)        \
+	{ \
+		scan_data_B = SCAN_ZERO_VAL;                       \
+		hf_B = 1u;                                         \
+	} \
+} \
+
+
+#define _FUNC_TREE_SCAN_BLOCK CAT(TreeScanBlockExc, tag)
+/**
+ * \brief Declares a block-wise exclusive tree scan function.
+ */
+#define DECLARE_TREE_SCAN_FUNC_BLOCK \
+void _FUNC_TREE_SCAN_BLOCK( \
+    uint groupIdx,                    \
+    uint gIdx,                        \
+    T initialData_A,                  \
+    T initialData_B,                  \
+    out T scanRes_A,                  \
+    out T scanRes_B                   \
+){ \
+  TreeScanIndices scanAddrs = GetTreeScanIndices(groupIdx, gIdx);						           \
+  uint ai = scanAddrs.lds_x2.x;                                                        \
+  uint bi = scanAddrs.lds_x2.y;                                                        \
+  /* Bank Offset == index >> bits_banks(5 in Nvidia card) */                         \
+  uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);                                       \
+  uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);                                       \
+                                                                                       \
+  /*  Store data into LDS with memory bank offset                                      \
+  ---------------------------------------------------------------------                \
+  about 'tailvalue':                                                                   \
+  in prefix sum, last elem is going to be erased                                       \
+  but we will need it later, so cache it here */                                       \
+  TREE_SCAN_CACHE[ai + aiOffset] = initialData_A;                                      \
+  TREE_SCAN_CACHE[bi + biOffset] = initialData_B;                                      \
+  /* about LDS memory layout:                                                          \
+  Interleaved storage,                                                                 \
+  that is, ith(i % 32 == 0) is not used;                                               \
+  e.g:                                                                                 \
+  [0, 31]  X [32, 63] X  [64, 95]  X [96, 127]  -- Input CBuffer                       \
+      + 0________+1___________+2___________+3 ... -- + OFFSET_BANK...(x)               \
+  [0, 31] 32 [33, 64] 65 [66, 97] 98 [99, 130]  -- TREE_SCAN_CACHE                   */\
+  \
+  \
+  \
+  /* //////////////////////////////////////////////////////////////////////// */       \
+  /* Scan --- Phase II        Up-Sweeping                                     */       \
+  /* Work Indices:                                                            */       \
+  /* offset = 2^k                                                             */       \
+  /* a(i, k) = (2^k) * (2i + 1) - 1 = (2*gidx)*offset + offset - 1            */       \
+  /* b(i, k) = a(i, k) + 2^k = a(i, k) + offset                               */       \
+  /* i ~ groupIdx, k ~ iteration, all start from 0.                           */       \
+  uint offset = 1;     /* Step Length == 2^k */                                        \
+  uint d = DATA_SIZE / 2u; /* [0, ... , d]th threads are dispatched */           \
+  for (; d > 0; d >>= 1){                                                       \
+      barrier();                                                                \
+      if (groupIdx < d){                                                        \
+          ai = offset * (2 * groupIdx + 1) - 1;                                 \
+          bi = offset * (2 * groupIdx + 2) - 1;                                 \
+          ai += OFFSET_BANK_CONFLICT_FREE(ai);                                  \
+          bi += OFFSET_BANK_CONFLICT_FREE(bi);                                  \
+                                                                                \
+          TREE_SCAN_CACHE[bi] = OP(TREE_SCAN_CACHE[ai], TREE_SCAN_CACHE[bi]);		\
+      }                                                                         \
+      offset *= 2;                                                              \
+  }                                                                             \
+  \
+  \
+  \
+  /* ////////////////////////////////////////////////////////////////////////*/ \
+  /* Phase III */                                                               \
+  if (groupIdx == 0)                                                            \
+  {                                                                             \
+      /* Zero out last elem, prepare for up-sweeping */                         \
+      uint lastIndex = DATA_SIZE - 1 + OFFSET_BANK_CONFLICT_FREE(DATA_SIZE - 1);\
+      TREE_SCAN_CACHE[lastIndex] = SCAN_ZERO_VAL;                               \
+  }                                                                             \
+  \
+  \
+  \
+  /* ///////////////////////////////////////////////////////////////////////// */ \
+  /* Phase IV                 Down-Sweeping                                    */ \
+  /* Util this point,                                                          */ \
+  /* d == 0,                                                                   */ \
+  /* offset == GROUP_SIZE * 2 == DATA_SIZE                                     */ \
+  /* This is actually "rolling back + mirror" version of Phase I,              */ \
+  /* So this execution code is a mirrored loop                                 */ \
+  for (d = 1; d < DATA_SIZE; d *= 2){                                              \
+      offset >>= 1;                                                                \
+      barrier();                                           \
+      if (groupIdx < d){                                                           \
+          /* So the indexing function is the same, (rolling back)                  \
+          just the roles of ai & bi are switched                              */   \
+          ai = offset * (2 * groupIdx + 1) - 1;                                    \
+          bi = offset * (2 * groupIdx + 2) - 1;                                    \
+          ai += OFFSET_BANK_CONFLICT_FREE(ai);                                     \
+          bi += OFFSET_BANK_CONFLICT_FREE(bi);                                     \
+          /* swap */                                                               \
+          T aiValOld = TREE_SCAN_CACHE[ai];                                        \
+          TREE_SCAN_CACHE[ai] = TREE_SCAN_CACHE[bi];                               \
+          TREE_SCAN_CACHE[bi] = OP(aiValOld, TREE_SCAN_CACHE[bi]);                 \
+      }                                                                            \
+  }                                                                                \
+  barrier();                                               \
+  \
+  \
+  \
+  T pSumAtAi = TREE_SCAN_CACHE[groupIdx + aiOffset];                               \
+  T pSumAtBi = TREE_SCAN_CACHE[groupIdx + SCAN_BLOCK_SIZE + biOffset];             \
+  \
+  \
+  scanRes_A = pSumAtAi;                                     \
+  scanRes_B = pSumAtBi;                                     \
+} \
+
+
+#define _FUNC_TREE_SCAN_AGGREGATE CAT(TreeScanBlockAggregate, tag)
+/**
+ \brief Second step for tree scan.
+ *  Apply exclusive scan on
+ *  inclusive sums from each scanned data-block.
+*/
+#define DECLARE_TREE_SCAN_FUNC_AGGREGATE \
+void _FUNC_TREE_SCAN_AGGREGATE( \
+  uint groupIdx,        \
+  uint gIdx,            \
+  T aggregateA,         \
+  T aggregateB,         \
+  out T aggSumA,        \
+  out T aggSumB         \
+) \
+{				                    \
+  _FUNC_TREE_SCAN_BLOCK	        \
+  (			                    \
+    groupIdx,                   \
+    gIdx,                       \
+    aggregateA,                 \
+    aggregateB,                 \
+    aggSumA, /*out*/            \
+    aggSumB  /*out*/            \
+  );			                    \
+} \
+
+
+
+
+
+
+/* -------------------------------------------------------------------- */
+/** \name Segmented Tree Scan
+ *
+ * \{ */
+#define _FUNC_TREE_SEG_SCAN_DWSWEEP_FILL_CACHE CAT(TreeSegScanExc_DwSweep_FillLDS_, tag)
+
+#define DECLARE_TREE_SEGSCAN_FUNC_DWSWEEP_FILL_CACHE	\
+void _FUNC_TREE_SEG_SCAN_DWSWEEP_FILL_CACHE(	\
+	uint groupId, 					\
+	TreeScanIndices scanAddrs, 	  \
+	/* --- LDS inputs --- */ 	     \
+	uint encodedHFs_A,	           \
+	T partialSum_A,	              \
+	uint encodedHFs_B,	           \
+	T partialSum_B,	              \
+	T aggregateScanRes 				  \
+) {																																\
+	uint ai = scanAddrs.lds_x2.x;																			            \
+	uint bi = scanAddrs.lds_x2.y;																			            \
+	\
+	/* Bank Offset == index >> bits_banks(5 in Nvidia card) */										      \
+	uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);													            \
+	uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);													            \
+	\
+	/*  Store data into LDS with memory bank offset								 	\
+	--------------------------------------------------------------------- 	\
+	about 'tailvalue':																		   \
+	in prefix sum, last elem is going to be erased								   \
+	but we will need it later, so cache it here                          */	\
+	uint cacheAddrAi = ai + aiOffset;																              \
+	uint cacheAddrBi = bi + biOffset;																              \
+	TREE_SCAN_CACHE[cacheAddrAi] = partialSum_A;													              \
+	TREE_SCAN_CACHE_HF[cacheAddrAi] = encodedHFs_A;													           \
+	/* Different from normal down-sweep that zeros out last elem, */								     \
+	/* We use output from prev inter-block scan kernel instead */									     \
+	TREE_SCAN_CACHE[cacheAddrBi] =                                                                 \
+		(groupId == SCAN_BLOCK_SIZE - 1)                                                            \
+			? aggregateScanRes : partialSum_B;	                                                     \
+	TREE_SCAN_CACHE_HF[cacheAddrBi] = encodedHFs_B;													           \
+} \
+
+
+#define _FUNC_TREE_SEG_SCAN_AGGREGATE_FILL_CACHE CAT(TreeSegScanExc_Aggregate_FillLDS_, tag)
+
+#define DECLARE_TREE_SEGSCAN_FUNC_AGGREGATE_FILL_CACHE \
+void _FUNC_TREE_SEG_SCAN_AGGREGATE_FILL_CACHE( \
+	uint groupId, 					\
+	TreeScanIndices scanAddrs, \
+	/* --- LDS inputs --- */ 	\
+	uint firstInitialHFAi,	   \
+	uint firstInitialHFBi	   \
+){ \
+	uint ai = scanAddrs.lds_x2.x;																			            \
+	uint bi = scanAddrs.lds_x2.y;																			            \
+	\
+	/* Bank Offset == index >> bits_banks(5 in Nvidia card) */										      \
+	uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);													            \
+	uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);													            \
+	uint cacheAddrAi = ai + aiOffset;																               \
+	uint cacheAddrBi = bi + biOffset;																               \
+	if (groupId == 0u)                                                                              \
+	{                                                                                               \
+		/* Zero out last elem, prepare for up-sweeping */                                          \
+		uint lastIndex = DATA_SIZE - 1 + OFFSET_BANK_CONFLICT_FREE(DATA_SIZE - 1);                   \
+		TREE_SCAN_CACHE[lastIndex] = SCAN_ZERO_VAL;                                                  \
+	}                                                                                               \
+	barrier();                                                                                      \
+	                                                                                                \
+	/* Compared to normal seg-scan,						  */                                            \
+	/* need to encode original hfs differently here */                                            \
+	TREE_SCAN_CACHE_HF[cacheAddrAi] = tree_seg_scan_encode_upsweep_hfs(                             \
+		TREE_SCAN_CACHE_HF[cacheAddrAi], firstInitialHFAi                                            \
+	);                                                                                              \
+	TREE_SCAN_CACHE_HF[cacheAddrBi] = tree_seg_scan_encode_upsweep_hfs(                             \
+		TREE_SCAN_CACHE_HF[cacheAddrBi], firstInitialHFBi                                            \
+	);                                                                                              \
+}
+
+
+#define _FUNC_TREE_SEG_SCAN_UPSWEEP CAT(TreeSegScanExc_UpSweep_, tag)
+
+#define DECLARE_TREE_SEGSCAN_FUNC_UPSWEEP	\
+void _FUNC_TREE_SEG_SCAN_UPSWEEP(	\
+	uint groupIdx,				        \
+	uint gIdx,                      \
+	/* --- scan inputs --- */ 	  \
+	uint headFlagAi,	              \
+	T initialDataAi,	              \
+	uint headFlagBi,	              \
+	T initialDataBi,	              \
+	/* --- block partial sums --- */ \
+ 	out uint headFlagPartialSum_A,  \
+	out T partialSum_A,		        \
+	out uint headFlagPartialSum_B,  \
+	out T partialSum_B		        \
+) \
+{ \
+	/* -------------------------------------------------------	*/									      \
+	/* nAddr:													*/									                     \
+	/* .x: Global_scanAddr0, .y: Global_scanAddr1, 				*/									         \
+	/* .z: LDS_scanAddr0, .w: LDS_scanAddr1						*/									            \
+	TreeScanIndices scanAddrs = GetTreeScanIndices(groupIdx, gIdx);									      \
+	uint ai = scanAddrs.lds_x2.x;																			            \
+	uint bi = scanAddrs.lds_x2.y;																			            \
+																																	\
+	/* Bank Offset == index >> bits_banks(5 in Nvidia card) */										      \
+	uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);													            \
+	uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);													            \
+																																	\
+	/*  Store data into LDS with memory bank offset								 \
+	--------------------------------------------------------------------- \
+	about 'tailvalue':																		\
+	in prefix sum, last elem is going to be erased								\
+	but we will need it later, so cache it here                          */	\
+	uint cacheAddrAi = ai + aiOffset;																               \
+	uint cacheAddrBi = bi + biOffset;																               \
+	TREE_SCAN_CACHE[cacheAddrAi] = initialDataAi;													            \
+	TREE_SCAN_CACHE_HF[cacheAddrAi] = headFlagAi;													            \
+	TREE_SCAN_CACHE[cacheAddrBi] = initialDataBi;													            \
+	TREE_SCAN_CACHE_HF[cacheAddrBi] = headFlagBi;													            \
+	/* about LDS memory layout:																		               \
+	Interleaved storage,																			                  \
+	that is, ith(i % 32 == 0) is not used;															            \
+	e.g:																							                        \
+	[0, 31]  X [32, 63] X  [64, 95]  X [96, 127]  -- Input CBuffer									      \
+		+ 0________+1___________+2___________+3 ... -- + OFFSET_BANK...(x)							   \
+	[0, 31] 32 [33, 64] 65 [66, 97] 98 [99, 130]  -- TREE_SCAN_CACHE			*/					      \
+                                                                                                	\
+                                                                                                	\
+	/* //////////////////////////////////////////////////////////////////////// */					\
+	/* Scan --- Phase II        Up-Sweeping                                     */					\
+	/* Work Indices:                                                            */					\
+	/* offset = 2^k                                                             */					\
+	/* a(i, k) = (2^k) * (2i + 1) - 1 = (2*gidx)*offset + offset - 1            */					\
+	/* b(i, k) = a(i, k) + 2^k = a(i, k) + offset                               */					\
+	/* i ~ groupIdx, k ~ iteration, all start from 0.                           */					\
+	uint offset = 1u; /* Step Length == 2^k */														            \
+	uint d = DATA_SIZE / 2u; /* [0, ... , d]th threads are dispatched */								   \
+                                                                                                   \
+	bool activeThread;																				                  \
+	for (; d > 0; d >>= 1)																			                  \
+	{																								                        \
+		activeThread = groupIdx < d;																                  \
+																																	\
+		ai = offset * (2u * groupIdx + 1u) - 1u;														            \
+		bi = offset * (2u * groupIdx + 2u) - 1u;														            \
+		ai += OFFSET_BANK_CONFLICT_FREE(ai);														               \
+		bi += OFFSET_BANK_CONFLICT_FREE(bi);														               \
+																																	\
+		barrier();															                                       \
+		bool isSegHeadAtBi = (0u != (1u & TREE_SCAN_CACHE_HF[bi]));												\
+		if (activeThread && (!isSegHeadAtBi))														               \
+		{																							                        \
+			TREE_SCAN_CACHE[bi] = OP(TREE_SCAN_CACHE[ai], TREE_SCAN_CACHE[bi]);						      \
+		}																							                        \
+		barrier();															                                       \
+	                                                                                                \
+		TREE_SCAN_CACHE_HF[bi] = activeThread																		   \
+			? uint(isSegHeadAtBi || bool(TREE_SCAN_CACHE_HF[ai]))												   \
+			: uint(isSegHeadAtBi);																		               \
+                                                                                                   \
+		offset *= 2u;																				                     \
+	}																								                        \
+                                                                                                   \
+	barrier();																                                       \
+                                                                                                   \
+																																	\
+	partialSum_A = TREE_SCAN_CACHE[cacheAddrAi];													               \
+	partialSum_B = TREE_SCAN_CACHE[cacheAddrBi];													               \
+	headFlagPartialSum_A = TREE_SCAN_CACHE_HF[cacheAddrAi];											         \
+	headFlagPartialSum_B = TREE_SCAN_CACHE_HF[cacheAddrBi];											         \
+} \
+
+
+#define _FUNC_TREE_SEG_SCAN_DWSWEEP CAT(TreeSegScanExc_DwSweep_, tag)
+
+#define DECLARE_TREE_SEGSCAN_FUNC_DWSWEEP	\
+void _FUNC_TREE_SEG_SCAN_DWSWEEP( \
+	uint groupIdx,	                  \
+	uint gIdx,		                  \
+	/* --- scan results --- */ \
+	out T scanResult_A,	            \
+	out T scanResult_B	            \
+) \
+{																									            \
+	/* Addressing & Data Loading											*/					         \
+	/* scanAddrs:																*/					         \
+	/* -- .x: Global_scanAddr0, .y: Global_scanAddr1, 			*/				            \
+	/* -- .z: LDS_scanAddr0,    .w: LDS_scanAddr1					*/					         \
+	TreeScanIndices scanAddrs = GetTreeScanIndices(groupIdx, gIdx);                     \
+	\
+	/* Bank Offset == index >> bits_banks(5 in Nvidia card) */                        \
+	uint ai = scanAddrs.lds_x2.x;																			\
+	uint bi = scanAddrs.lds_x2.y;																			\
+	uint aiOffset = OFFSET_BANK_CONFLICT_FREE(ai);													\
+	uint biOffset = OFFSET_BANK_CONFLICT_FREE(bi);													\
+	\
+	/*  Store data into LDS with memory bank offset												\
+	/* instead should call "_FUNC_TREE_SEG_SCAN_FILL_CACHE"                            \
+	* ---------------------------------------------------------------------				\
+	* about 'tailvalue':																				   \
+	* in prefix sum, last elem is going to be erased												\
+	* but we will need it later, so cache it here */					                     \
+	uint cacheAddrAi = ai + aiOffset;																   \
+	uint cacheAddrBi = bi + biOffset;																   \
+	/**TREE_SCAN_CACHE[cacheAddrAi] = partialSum_A;		*/										\
+	/**TREE_SCAN_CACHE_HF[cacheAddrAi] = encodedHFs_A;	*/										\
+	/**TREE_SCAN_CACHE[cacheAddrBi] = partialSum_B;		*/										\
+	/**TREE_SCAN_CACHE_HF[cacheAddrBi] = encodedHFs_B;	*/										\
+	\
+	\
+	/* ///////////////////////////////////////////////////////////////////////// */	\
+	/* Phase IV                 Down-Sweeping                                    */	\
+	/* Util this point,                                                          */	\
+	/* d == 0,                                                                   */	\
+	/* offset == GROUP_SIZE * 2 == DATA_SIZE                                     */	\
+	/* This is actually "rolling back + mirror" version of Phase I,              */	\
+	/* So this execution code is a mirrored loop                                 */	\
+	uint offset = DATA_SIZE;																		      \
+	uint d = 0u;																						      \
+	bool activeThread;																				      \
+	for (d = 1u; d < DATA_SIZE; d *= 2u)																\
+	{																								            \
+		offset >>= 1;																				         \
+		/* So the indexing function is the same, (rolling back)	                    \
+		 * just the roles of ai & bi are switched */                                   \
+		ai = offset * (2u * groupIdx + 1u) - 1u;														\
+		bi = offset * (2u * groupIdx + 2u) - 1u;														\
+		uint aiNext = ai + 1u + OFFSET_BANK_CONFLICT_FREE(ai + 1u);						      \
+		ai += OFFSET_BANK_CONFLICT_FREE(ai);														   \
+		bi += OFFSET_BANK_CONFLICT_FREE(bi);														   \
+	                                                                                    \
+		activeThread = groupIdx < d;																      \
+		                                                                                 \
+		barrier();															                           \
+		T valAi = TREE_SCAN_CACHE[ai];																   \
+		T valBi = TREE_SCAN_CACHE[bi];																   \
+		                                                                                 \
+		barrier();															                           \
+		if (activeThread) /* swap */																      \
+			TREE_SCAN_CACHE[ai] = valBi;															      \
+		                                                                                 \
+		barrier();															                           \
+		uint origHFAiNext = /*DECODE_ORIG_HF(TREE_SCAN_CACHE_HF[aiNext]);*/            \
+			tree_seg_scan_decode_upsweep_hfs_get_origHF(TREE_SCAN_CACHE_HF[aiNext]);	   \
+		uint currHFAi = /**DECODE_CURR_HF(TREE_SCAN_CACHE_HF[ai]);*/							\
+			tree_seg_scan_decode_upsweep_hfs_get_sumHF(TREE_SCAN_CACHE_HF[ai]);           \
+		                                                                                 \
+		if (activeThread)																			         \
+		{																							            \
+			TREE_SCAN_CACHE[bi] = (origHFAiNext == 1u)                                    \
+ 				? SCAN_ZERO_VAL : ((currHFAi == 1u) ? valAi : OP(valAi, valBi));           \
+		}																							            \
+		                                                                                 \
+		barrier();															                           \
+		/* Clear partial sum hf, keep original flag */										   \
+		TREE_SCAN_CACHE_HF[ai] &= 0x00000002u;														   \
+	}																								            \
+	                                                                                    \
+	barrier();																                           \
+	                                                                                    \
+	scanResult_A = TREE_SCAN_CACHE[cacheAddrAi];                                        \
+	scanResult_B = TREE_SCAN_CACHE[cacheAddrBi];                                        \
+} \
+
+
+
+/** \} */
+
+
+
+
+#endif
+
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
new file mode 100644
index 00000000000..30b1fc097a8
--- /dev/null
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
@@ -0,0 +1,279 @@
+#pragma BLENDER_REQUIRE(bnpr_scan_no_subgroup_codegen_lib.glsl)
+
+
+/* input buffers:
+ * -----------------------------------------------
+ * BnprScanDataBuf        bnpr_in_scan_data_buf_
+ * BnprScanDataBuf        bnpr_out_scan_data_buf_
+ * BnprScanBlockSumBuf    bnpr_scan_block_sum_buf_
+*/
+
+#define T_To_Uint(x) x
+#define Uint_To_T(x) x
+
+#if defined(_KERNEL_MULTI_COMPILE__TREE_SCAN_UPSWEEP)
+void main()
+{
+  const uint groupId =  gl_LocalInvocationID.x;
+
+  TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
+
+  T scanval_A, scanval_B;
+  { /* init & store random scan input vals */
+    scanval_A = T(
+      wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.x) % 12u
+    );
+    scanval_B = T(
+      wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.y) % 12u
+    );
+    /* avoid invalid loads */
+    _FUNC_CLEAN_SCAN_DATA(
+      scan_ids, ubo_bnpr_tree_scan_infos_.num_scan_items,
+      scanval_A, scanval_B /* <- inout */
+    );
+    bnpr_in_scan_data_buf_[scan_ids.global_x2.x] = /**floatBitsToUint*/(scanval_A);
+    bnpr_in_scan_data_buf_[scan_ids.global_x2.y] = /**floatBitsToUint*/(scanval_B);
+  }
+
+
+
+  /* execute block-wise exlusive scan */
+  T scanRes_ai, scanRes_bi;
+  _FUNC_TREE_SCAN_BLOCK(
+        groupId,
+        gl_WorkGroupID.x,
+        scanval_A,
+        scanval_B,
+        /* -out- */
+        scanRes_ai,
+        scanRes_bi
+  );
+
+  /* store scan results */
+  bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = /**floatBitsToUint*/(scanRes_ai);
+  bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = /**floatBitsToUint*/(scanRes_bi);
+
+  /* store block aggregate */
+  if (groupId == gl_WorkGroupSize.x - 1)
+  {
+    bnpr_scan_block_sum_buf_[gl_WorkGroupID.x] = /**floatBitsToUint*/(SCAN_OP(scanRes_bi, scanval_B));
+  }
+}
+#endif
+
+
+
+
+
+
+#if defined(_KERNEL_MULTI_COMPILE__TREE_SCAN_AGGREGATE)
+void main()
+{
+  const uint groupId =  gl_LocalInvocationID.x;
+  const uint gIdx =     gl_WorkGroupID.x;
+
+  TreeScanIndices scanAddrs = GetTreeScanIndices(groupId, 0);
+  T aggregate_A = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[scanAddrs.global_x2.x]);
+  T aggregate_B = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[scanAddrs.global_x2.y]);
+
+  T aggregateSum_A, aggregateSum_B;
+  _FUNC_TREE_SCAN_AGGREGATE(
+	  groupId,
+	  gIdx,
+	  aggregate_A,
+	  aggregate_B,
+	  aggregateSum_A,
+	  aggregateSum_B
+  );
+
+  bnpr_scan_block_sum_buf_[scanAddrs.global_x2.x] = /**floatBitsToUint*/(aggregateSum_A);
+  bnpr_scan_block_sum_buf_[scanAddrs.global_x2.y] = /**floatBitsToUint*/(aggregateSum_B);
+
+
+}
+#endif
+
+
+
+
+
+
+#if defined(_KERNEL_MULTI_COMPILE__TREE_SCAN_DWSWEEP)
+void main()
+{
+	const uint groupId = gl_LocalInvocationID.x;
+	const uint gIdx = gl_WorkGroupID.x;
+
+	TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
+
+	T block_scan_res_A, block_scan_res_B;
+	block_scan_res_A = /**uintBitsToFloat*/(bnpr_out_scan_data_buf_[scan_ids.global_x2[0]]);
+	block_scan_res_B = /**uintBitsToFloat*/(bnpr_out_scan_data_buf_[scan_ids.global_x2[1]]);
+
+	T aggregate_sum = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[gIdx]);
+
+	bnpr_out_scan_data_buf_[scan_ids.global_x2[0]] = /**floatBitsToUint*/(SCAN_OP(aggregate_sum, block_scan_res_A));
+	bnpr_out_scan_data_buf_[scan_ids.global_x2[1]] = /**floatBitsToUint*/(SCAN_OP(aggregate_sum, block_scan_res_B));
+}
+#endif
+
+
+
+#if defined(_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_UPSWEEP)
+void main()
+{
+	const uint groupId =  gl_LocalInvocationID.x;
+
+	TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
+
+	T scanval_A, scanval_B;
+	uint hf_A, hf_B;
+	{ /* init & store random scan input vals */
+		hf_A = 1u & (wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.x) % 892u);
+		scanval_A = T(
+			wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.x) % 12u
+		);
+		hf_B = 1u & (wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.y) % 892u);
+		scanval_B = T(
+			wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.y) % 12u
+		);
+		/* avoid invalid loads */
+		_FUNC_CLEAN_SEG_SCAN_DATA(
+			scan_ids, ubo_bnpr_tree_scan_infos_.num_scan_items,
+			hf_A, scanval_A, hf_B, scanval_B /* <- inout */
+		);
+		bnpr_in_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(hf_A, scanval_A);
+		bnpr_in_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(hf_B, scanval_B);
+	}
+
+
+
+	/* execute block-wise exlusive scan */
+	uint headFlagPartialSum_A, headFlagPartialSum_B;
+	T scanRes_ai, scanRes_bi;
+	_FUNC_TREE_SEG_SCAN_UPSWEEP(
+		groupId,
+		gl_WorkGroupID.x,
+		hf_A, 						scanval_A,
+		hf_B, 						scanval_B,
+		/* -out- */
+		headFlagPartialSum_A, 	scanRes_ai,
+		headFlagPartialSum_B, 	scanRes_bi
+	);
+
+	/* store scan results */
+	bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(
+		tree_seg_scan_encode_upsweep_hfs(hf_A, headFlagPartialSum_A),
+		scanRes_ai
+	);
+	bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(
+		tree_seg_scan_encode_upsweep_hfs(hf_B, headFlagPartialSum_B),
+		scanRes_bi
+	);
+
+	/* store block aggregate */
+	if (groupId == gl_WorkGroupSize.x - 1)
+	{
+		bnpr_scan_block_sum_buf_[gl_WorkGroupID.x] = SEGSCAN_STRUCT_TYPE(
+			tree_seg_scan_encode_upsweep_hfs(
+				headFlagPartialSum_B,  /* or sum of block hfs */
+				TREE_SCAN_CACHE_HF[0]  /* original hf of block */
+			),
+			/* different from ordinary scan, we store exclusive sum here */
+			scanval_B
+		);
+	}
+}
+#endif
+
+
+#if defined(_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_AGGREGATE)
+void main()
+{
+	const uint groupId = gl_LocalInvocationID.x;
+	const uint gIdx = gl_WorkGroupID.x;
+
+	TreeScanIndices scan_ids = GetTreeScanIndices(groupId, 0);
+
+	SEGSCAN_STRUCT_TYPE aggregate_A = bnpr_scan_block_sum_buf_[scan_ids.global_x2.x];
+	T partialSumTreeAi = aggregate_A.val;
+	uint partialOrTreeAi = tree_seg_scan_decode_upsweep_hfs_get_sumHF(aggregate_A.hf);
+	uint firstInitialHFAi = tree_seg_scan_decode_upsweep_hfs_get_origHF(aggregate_A.hf);
+
+	SEGSCAN_STRUCT_TYPE aggregate_B = bnpr_scan_block_sum_buf_[scan_ids.global_x2.y];
+	T partialSumTreeBi = aggregate_B.val;
+	uint partialOrTreeBi = tree_seg_scan_decode_upsweep_hfs_get_sumHF(aggregate_B.hf);
+	uint firstInitialHFBi = tree_seg_scan_decode_upsweep_hfs_get_origHF(aggregate_B.hf);
+
+	T upsweep_res_sum_A, upsweep_res_sum_B;
+	uint upsweep_res_hf_A, upsweep_res_hf_B;
+	_FUNC_TREE_SEG_SCAN_UPSWEEP(
+		groupId,
+		gl_WorkGroupID.x,
+		partialOrTreeAi, partialSumTreeAi,
+		partialOrTreeBi, partialSumTreeBi,
+		/* -out- */
+		upsweep_res_hf_A, upsweep_res_sum_A,
+		upsweep_res_hf_B, upsweep_res_sum_B
+	);
+
+
+
+	_FUNC_TREE_SEG_SCAN_AGGREGATE_FILL_CACHE(
+		groupId, scan_ids,
+		/* --- LDS inputs --- */
+		firstInitialHFAi, firstInitialHFBi
+	);
+
+
+
+	T scan_res_A, scan_res_B;
+	_FUNC_TREE_SEG_SCAN_DWSWEEP
+	(
+		groupId, gIdx,
+		/* --- out --- */
+		scan_res_A, scan_res_B
+	);
+
+
+	/* store scan results */
+	bnpr_scan_block_sum_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(0, scan_res_A); /* no hf needed */
+	bnpr_scan_block_sum_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(0, scan_res_B); /* no hf needed */
+}
+#endif
+
+
+#if defined(_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_DWSWEEP)
+void main()
+{
+	const uint groupId = gl_LocalInvocationID.x;
+	const uint gIdx = gl_WorkGroupID.x;
+
+	TreeScanIndices scan_ids = GetTreeScanIndices(groupId, gl_WorkGroupID.x);
+
+	SEGSCAN_STRUCT_TYPE block_scan_res_A, block_scan_res_B, aggregate_scan_res;
+	block_scan_res_A = /**uintBitsToFloat*/(bnpr_out_scan_data_buf_[scan_ids.global_x2.x]);
+	block_scan_res_B = /**uintBitsToFloat*/(bnpr_out_scan_data_buf_[scan_ids.global_x2.y]);
+	aggregate_scan_res = /**uintBitsToFloat*/(bnpr_scan_block_sum_buf_[gIdx]);
+
+	_FUNC_TREE_SEG_SCAN_DWSWEEP_FILL_CACHE(
+		groupId, scan_ids,
+		/* --- block partial sums --- */
+		block_scan_res_A.hf, block_scan_res_A.val,
+		block_scan_res_B.hf, block_scan_res_B.val,
+		/* --- scanned block aggregate --- */
+		aggregate_scan_res.val
+	);
+
+	T scan_res_A, scan_res_B;
+	_FUNC_TREE_SEG_SCAN_DWSWEEP
+	(
+		groupId, gIdx,
+		/* --- out --- */
+		scan_res_A, scan_res_B
+	);
+
+	bnpr_out_scan_data_buf_[scan_ids.global_x2.x] = SEGSCAN_STRUCT_TYPE(block_scan_res_A.hf, scan_res_A);
+	bnpr_out_scan_data_buf_[scan_ids.global_x2.y] = SEGSCAN_STRUCT_TYPE(block_scan_res_B.hf, scan_res_B);
+}
+#endif
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
index 964ee4114e3..b34970b05d3 100644
--- a/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_strokegen_test_comp.glsl
@@ -7,5 +7,5 @@
 
 void main()
 {
-
+  buf_test[0] = buf_ibo[0];
 }
diff --git a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
index bea2190c8d3..410ed1085ac 100644
--- a/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
+++ b/source/blender/draw/engines/bnpr/shaders/infos/bnpr_test_info.hh
@@ -57,14 +57,135 @@
 /** \} */
 
 
+/* -------------------------------------------------------------------- */
+/** \shared shader infos
+ * \{ */
+GPU_SHADER_CREATE_INFO(bnpr_scan_uint_add)
+  .typedef_source("bnpr_shader_shared.hh")
+  .define("SCAN_DATA_TYPE", "uint")
+  .define("SCAN_OP", "u32_add")
+  .define("SCAN_ZERO_VAL", "0u")
+  .define("SCAN_FUNCTION_TAG", "_u32_add")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_uvec2_add)
+  .typedef_source("bnpr_shader_shared.hh")
+  .define("SCAN_DATA_TYPE", "uvec2")
+  .define("SCAN_OP", "uvec2_add")
+  .define("SCAN_ZERO_VAL", "uvec2(0u, 0u)")
+  .define("SCAN_FUNCTION_TAG", "uvec2_add")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_uvec3_add)
+  .typedef_source("bnpr_shader_shared.hh")
+  .define("SCAN_DATA_TYPE", "uvec3")
+  .define("SCAN_OP", "uvec3_add")
+  .define("SCAN_ZERO_VAL", "uvec3(0u, 0u, 0u)")
+  .define("SCAN_FUNCTION_TAG", "uvec3_add")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_uvec4_add)
+  .typedef_source("bnpr_shader_shared.hh")
+  .define("SCAN_DATA_TYPE", "uvec4")
+  .define("SCAN_OP", "uvec4_add")
+  .define("SCAN_ZERO_VAL", "uvec4(0u, 0u, 0u, 0u)")
+  .define("SCAN_FUNCTION_TAG", "uvec4_add")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_float_add)
+  .typedef_source("bnpr_shader_shared.hh")
+  .define("SCAN_DATA_TYPE", "float")
+  .define("SCAN_OP", "f32_add")
+  .define("SCAN_ZERO_VAL", ".0f")
+  .define("SCAN_FUNCTION_TAG", "_f32_add")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_test_inputs)
+  .additional_info("bnpr_scan_uvec3_add")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_segscan_test_inputs)
+  .additional_info("bnpr_scan_uvec3_add")
+  .define("SEGSCAN_STRUCT_TYPE", "SSBOData_SegScanTest")
+;
+
 
 /* -------------------------------------------------------------------- */
-/** \test
+/** \test shaders
  * \{ */
 GPU_SHADER_CREATE_INFO(bnpr_strokegen_test_xxx)
   .do_static_compilation(true)
-  .storage_buf(0, Qualifier::READ_WRITE, "uint", "buf_test")
+  .storage_buf(0, Qualifier::READ_WRITE, "uint", "buf_test[]")
+  .storage_buf(1, Qualifier::READ, "uint", "buf_ibo[]")
   .local_group_size(GROUP_SIZE_STROKEGEN_TEST) /* <== from "bnpr_defines.hh" */
-  .compute_source("bnpr_strokegen_test_comp.glsl");
+  .compute_source("bnpr_strokegen_test_comp.glsl")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_test_upsweep)
+  .do_static_compilation(true)
+  .additional_info("bnpr_scan_test_inputs")
+  .define("_KERNEL_MULTI_COMPILE__TREE_SCAN_UPSWEEP", "1")
+  .storage_buf(0, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_in_scan_data_buf_[]")
+  .storage_buf(1, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_out_scan_data_buf_[]")
+  .storage_buf(2, Qualifier::WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
+  .uniform_buf(0, "UBData_TreeScan", "ubo_bnpr_tree_scan_infos_")
+  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_SWEEP) /* <== from "bnpr_defines.hh" */
+  .compute_source("bnpr_scan_test_comp.glsl")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_test_aggregate)
+  .do_static_compilation(true)
+  .additional_info("bnpr_scan_test_inputs")
+  .define("_KERNEL_MULTI_COMPILE__TREE_SCAN_AGGREGATE", "1")
+  .storage_buf(0, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
+  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_AGGRG) /* <== from "bnpr_defines.hh" */
+  .compute_source("bnpr_scan_test_comp.glsl")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_scan_test_dwsweep)
+  .do_static_compilation(true)
+  .additional_info("bnpr_scan_test_inputs")
+  .define("_KERNEL_MULTI_COMPILE__TREE_SCAN_DWSWEEP", "1")
+  .storage_buf(0, Qualifier::READ_WRITE, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_out_scan_data_buf_[]")
+  .storage_buf(1, Qualifier::READ, BNPR_SCAN_TEST_DATA_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
+  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_SWEEP) /* <== from "bnpr_defines.hh" */
+  .compute_source("bnpr_scan_test_comp.glsl")
+;
+
+
+GPU_SHADER_CREATE_INFO(bnpr_segscan_test_upsweep)
+  .do_static_compilation(true)
+  .additional_info("bnpr_segscan_test_inputs")
+  .define("IS_TREE_SEG_SCAN", "1")
+  .define("_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_UPSWEEP", "1")
+  .storage_buf(0, Qualifier::READ_WRITE,  BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_in_scan_data_buf_[]")
+  .storage_buf(1, Qualifier::READ_WRITE,  BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_out_scan_data_buf_[]")
+  .storage_buf(2, Qualifier::WRITE,       BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
+  .uniform_buf(0, "UBData_TreeScan", "ubo_bnpr_tree_scan_infos_")
+  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_SWEEP) /* <== from "bnpr_defines.hh" */
+  .compute_source("bnpr_scan_test_comp.glsl")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_segscan_test_aggregate)
+  .do_static_compilation(true)
+  .additional_info("bnpr_segscan_test_inputs")
+  .define("IS_TREE_SEG_SCAN", "1")
+  .define("_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_AGGREGATE", "1")
+  .storage_buf(0, Qualifier::READ_WRITE, BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
+  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_AGGRG) /* <== from "bnpr_defines.hh" */
+  .compute_source("bnpr_scan_test_comp.glsl")
+;
+
+GPU_SHADER_CREATE_INFO(bnpr_segscan_test_dwsweep)
+  .do_static_compilation(true)
+  .additional_info("bnpr_segscan_test_inputs")
+  .define("IS_TREE_SEG_SCAN",                             "1")
+  .define("_KERNEL_MULTI_COMPILE__TREE_SEG_SCAN_DWSWEEP", "1")
+  .storage_buf(0, Qualifier::READ_WRITE,  BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_out_scan_data_buf_[]")
+  .storage_buf(1, Qualifier::READ,  BNPR_SEG_SCAN_TEST_STRUCT_TYPE_STR, "bnpr_scan_block_sum_buf_[]")
+  .uniform_buf(0, "UBData_TreeScan", "ubo_bnpr_tree_scan_infos_")
+  .local_group_size(GROUP_SIZE_BNPR_SCAN_TEST_SWEEP) /* <== from "bnpr_defines.hh" */
+  .compute_source("bnpr_scan_test_comp.glsl")
+;
 
 /** \} */
-- 
2.38.1.windows.1


From ce1b4301d24dc432ac5016f6b596c4870515db0c Mon Sep 17 00:00:00 2001
From: Jiang <jwtstone@gmail.com>
Date: Thu, 12 Jan 2023 00:07:25 +0800
Subject: [PATCH 11/11] Learning ssbo alignment

---
 source/blender/draw/engines/bnpr/bnpr_defines.hh     |  2 +-
 .../engines/bnpr/shaders/bnpr_scan_test_comp.glsl    | 12 ++++++------
 2 files changed, 7 insertions(+), 7 deletions(-)

diff --git a/source/blender/draw/engines/bnpr/bnpr_defines.hh b/source/blender/draw/engines/bnpr/bnpr_defines.hh
index 4cc48d0ddd0..f56a53922e9 100644
--- a/source/blender/draw/engines/bnpr/bnpr_defines.hh
+++ b/source/blender/draw/engines/bnpr/bnpr_defines.hh
@@ -19,7 +19,7 @@
 
 
 #ifndef GPU_SHADER
-# define BNPR_SCAN_TEST_DATA_TYPE uint4
+# define BNPR_SCAN_TEST_DATA_TYPE uint3
 # define BNPR_SCAN_TEST_DATA_TYPE_STR "uvec3"
 
 // remember to update SSBOData_SegScanTest if this changes
diff --git a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
index 30b1fc097a8..62d535037b5 100644
--- a/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
+++ b/source/blender/draw/engines/bnpr/shaders/bnpr_scan_test_comp.glsl
@@ -129,14 +129,14 @@ void main()
 	T scanval_A, scanval_B;
 	uint hf_A, hf_B;
 	{ /* init & store random scan input vals */
-		hf_A = 1u & (wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.x) % 892u);
-		scanval_A = T(
+		hf_A = 0xffffffff; /**uint(scan_ids.global_x2.x % 3u == 0u);*/ /**1u & (wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.x) % 892u);*/
+		scanval_A = T(scan_ids.global_x2.x); /**T(
 			wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.x) % 12u
-		);
-		hf_B = 1u & (wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.y) % 892u);
-		scanval_B = T(
+		);*/
+		hf_B = 0xffffffff;/**uint(scan_ids.global_x2.y % 3u == 0u);*//**1u & (wang_hash(scan_ids.global_x2.y + scan_ids.lds_x2.y) % 892u)*/;
+		scanval_B = T(scan_ids.global_x2.y); /**T(
 			wang_hash(scan_ids.global_x2.x + scan_ids.lds_x2.y) % 12u
-		);
+		);*/
 		/* avoid invalid loads */
 		_FUNC_CLEAN_SEG_SCAN_DATA(
 			scan_ids, ubo_bnpr_tree_scan_infos_.num_scan_items,
-- 
2.38.1.windows.1

